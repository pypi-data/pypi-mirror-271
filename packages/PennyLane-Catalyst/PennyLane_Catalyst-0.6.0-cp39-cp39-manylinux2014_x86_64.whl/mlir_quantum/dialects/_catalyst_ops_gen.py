
# Autogenerated by mlir-tblgen; don't manually edit.

from ._ods_common import _cext as _ods_cext
from ._ods_common import (
    SubClassValueT as _SubClassValueT,
    equally_sized_accessor as _ods_equally_sized_accessor,
    get_default_loc_context as _ods_get_default_loc_context,
    get_op_result_or_op_results as _get_op_result_or_op_results,
    get_op_result_or_value as _get_op_result_or_value,
    get_op_results_or_values as _get_op_results_or_values,
    segmented_accessor as _ods_segmented_accessor,
)
_ods_ir = _ods_cext.ir

import builtins
from typing import Sequence as _Sequence, Union as _Union


@_ods_cext.register_dialect
class _Dialect(_ods_ir.Dialect):
  DIALECT_NAMESPACE = "catalyst"
  pass


@_ods_cext.register_operation(_Dialect)
class CustomCallOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.custom_call"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, call_target_name, *, number_original_arg=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["call_target_name"] = (call_target_name if (
    issubclass(type(call_target_name), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('StrAttr')) else
      _ods_ir.AttrBuilder.get('StrAttr')(call_target_name, context=_ods_context))
    if number_original_arg is not None: attributes["number_original_arg"] = (number_original_arg if (
        issubclass(type(number_original_arg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('DenseI32ArrayAttr')) else
          _ods_ir.AttrBuilder.get('DenseI32ArrayAttr')(number_original_arg, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def call_target_name(self):
    return self.operation.attributes["call_target_name"]

  @call_target_name.setter
  def call_target_name(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["call_target_name"] = value

  @builtins.property
  def number_original_arg(self):
    if "number_original_arg" not in self.operation.attributes:
      return None
    return self.operation.attributes["number_original_arg"]

  @number_original_arg.setter
  def number_original_arg(self, value):
    if value is not None:
      self.operation.attributes["number_original_arg"] = value
    elif "number_original_arg" in self.operation.attributes:
      del self.operation.attributes["number_original_arg"]

  @number_original_arg.deleter
  def number_original_arg(self):
    del self.operation.attributes["number_original_arg"]

def custom_call(result, inputs, call_target_name, *, number_original_arg=None, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(CustomCallOp(result=result, inputs=inputs, call_target_name=call_target_name, number_original_arg=number_original_arg, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ListDeallocOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.list_dealloc"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

def list_dealloc(list, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(ListDeallocOp(list=list, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ListInitOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.list_init"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(list)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.results[0]

def list_init(list, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ListInitOp(list=list, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ListLoadDataOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.list_load_data"

  _ODS_REGIONS = (0, True)

  def __init__(self, data, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    _ods_context = _ods_get_default_loc_context(loc)
    results.append(data)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def data(self):
    return self.operation.results[0]

def list_load_data(data, list, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ListLoadDataOp(data=data, list=list, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ListPopOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.list_pop"

  _ODS_REGIONS = (0, True)

  def __init__(self, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(list))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def list(self):
    return self.operation.operands[0]

  @builtins.property
  def result(self):
    return self.operation.results[0]

def list_pop(list, *, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(ListPopOp(list=list, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class ListPushOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.list_push"

  _ODS_REGIONS = (0, True)

  def __init__(self, value, list, *, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.append(_get_op_result_or_value(value))
    operands.append(_get_op_result_or_value(list))
    _ods_context = _ods_get_default_loc_context(loc)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def value(self):
    return self.operation.operands[0]

  @builtins.property
  def list(self):
    return self.operation.operands[1]

def list_push(value, list, *, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(ListPushOp(value=value, list=list, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PrintOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.print"

  _ODS_REGIONS = (0, True)

  def __init__(self, *, val=None, const_val=None, print_descriptor=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    if val is not None: operands.append(_get_op_result_or_value(val))
    _ods_context = _ods_get_default_loc_context(loc)
    if const_val is not None: attributes["const_val"] = (const_val if (
        issubclass(type(const_val), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('StrAttr')) else
          _ods_ir.AttrBuilder.get('StrAttr')(const_val, context=_ods_context))
    if bool(print_descriptor): attributes["print_descriptor"] = _ods_ir.UnitAttr.get(
      _ods_get_default_loc_context(loc))
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def val(self):
    return None if len(self.operation.operands) < 1 else self.operation.operands[0]

  @builtins.property
  def const_val(self):
    if "const_val" not in self.operation.attributes:
      return None
    return self.operation.attributes["const_val"]

  @const_val.setter
  def const_val(self, value):
    if value is not None:
      self.operation.attributes["const_val"] = value
    elif "const_val" in self.operation.attributes:
      del self.operation.attributes["const_val"]

  @const_val.deleter
  def const_val(self):
    del self.operation.attributes["const_val"]

  @builtins.property
  def print_descriptor(self):
    return "print_descriptor" in self.operation.attributes

  @print_descriptor.setter
  def print_descriptor(self, value):
    if bool(value):
      self.operation.attributes["print_descriptor"] = _ods_ir.UnitAttr.get()
    elif "print_descriptor" in self.operation.attributes:
      del self.operation.attributes["print_descriptor"]

  @print_descriptor.deleter
  def print_descriptor(self):
    del self.operation.attributes["print_descriptor"]

def print_(*, val=None, const_val=None, print_descriptor=None, loc=None, ip=None) -> _ods_ir.Operation:
  return _get_op_result_or_op_results(PrintOp(val=val, const_val=const_val, print_descriptor=print_descriptor, loc=loc, ip=ip))

@_ods_cext.register_operation(_Dialect)
class PythonCallOp(_ods_ir.OpView):
  OPERATION_NAME = "catalyst.pycallback"

  _ODS_REGIONS = (0, True)

  def __init__(self, result, inputs, identifier, *, number_original_arg=None, loc=None, ip=None):
    operands = []
    results = []
    attributes = {}
    regions = None
    operands.extend(_get_op_results_or_values(inputs))
    _ods_context = _ods_get_default_loc_context(loc)
    attributes["identifier"] = (identifier if (
    issubclass(type(identifier), _ods_ir.Attribute) or
    not _ods_ir.AttrBuilder.contains('I64Attr')) else
      _ods_ir.AttrBuilder.get('I64Attr')(identifier, context=_ods_context))
    if number_original_arg is not None: attributes["number_original_arg"] = (number_original_arg if (
        issubclass(type(number_original_arg), _ods_ir.Attribute) or
        not _ods_ir.AttrBuilder.contains('I64Attr')) else
          _ods_ir.AttrBuilder.get('I64Attr')(number_original_arg, context=_ods_context))
    results.extend(result)
    _ods_successors = None
    super().__init__(self.build_generic(attributes=attributes, results=results, operands=operands, successors=_ods_successors, regions=regions, loc=loc, ip=ip))

  @builtins.property
  def inputs(self):
    _ods_variadic_group_length = len(self.operation.operands) - 1 + 1
    return self.operation.operands[0:0 + _ods_variadic_group_length]

  @builtins.property
  def identifier(self):
    return self.operation.attributes["identifier"]

  @identifier.setter
  def identifier(self, value):
    if value is None:
      raise ValueError("'None' not allowed as value for mandatory attributes")
    self.operation.attributes["identifier"] = value

  @builtins.property
  def number_original_arg(self):
    if "number_original_arg" not in self.operation.attributes:
      return None
    return self.operation.attributes["number_original_arg"]

  @number_original_arg.setter
  def number_original_arg(self, value):
    if value is not None:
      self.operation.attributes["number_original_arg"] = value
    elif "number_original_arg" in self.operation.attributes:
      del self.operation.attributes["number_original_arg"]

  @number_original_arg.deleter
  def number_original_arg(self):
    del self.operation.attributes["number_original_arg"]

def pycallback(result, inputs, identifier, *, number_original_arg=None, loc=None, ip=None) -> _SubClassValueT:
  return _get_op_result_or_op_results(PythonCallOp(result=result, inputs=inputs, identifier=identifier, number_original_arg=number_original_arg, loc=loc, ip=ip))
