from typing import Dict, Generic, List, Optional, Tuple, TypeVar, Union
import pprint

import baml_py
from pydantic import BaseModel, ValidationError

from . import types

OutputType = TypeVar('OutputType')

class BamlOutputWrapper(BaseModel, Generic[OutputType]):
    wrapped: OutputType

{% for fn in funcs -%}
class BamlOutput_{{fn.name}}:
    __runtime: baml_py.BamlRuntimeFfi

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime

    async def __call__(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> {{fn.return_type}}:
      raw = await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )
      parsed = raw.parsed()
      try:
        return BamlOutputWrapper[{{ fn.return_type }}].model_validate(obj={'wrapped': parsed}).wrapped
      except ValidationError as e:
        raise TypeError(
          "Internal BAML error while mapping the FFI output type for {{fn.name}}:\n{}".format(
            pprint.pformat(parsed)
          )
        ) from e

    async def unstable(
        self,
        {% for (name, type) in fn.args -%}
        {{name}}: {{type}}{% if !loop.last %},{% endif %}
        {%- endfor %}
    ) -> baml_py.FunctionResult:
      return await self.__runtime.call_function(
        "{{fn.name}}",
        {
          {% for (name, _) in fn.args -%}
          "{{name}}": {{name}},
          {%- endfor %}
        },
        ctx={}
      )

{% endfor %}

class BamlClient:
    __runtime: baml_py.BamlRuntimeFfi
    {%- for fn in funcs %}
    {{fn.name}}: BamlOutput_{{fn.name}}
    {%- endfor %}

    @staticmethod
    def from_encoded(encoded: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_encoded(encoded))

    @staticmethod
    def from_directory(path: str) -> "BamlClient":
      return BamlClient(runtime=baml_py.BamlRuntimeFfi.from_directory(path))

    def __init__(self, runtime: baml_py.BamlRuntimeFfi):
      self.__runtime = runtime
      {%- for fn in funcs %}
      self.{{fn.name}} = BamlOutput_{{fn.name}}(self.__runtime)
      {%- endfor %}
