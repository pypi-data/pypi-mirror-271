'''
# CDK Static Wordpress

The goal of this project is to make it easy to deploy a static website, generated by [Wordpress](https://wordpress.org/)
as simple and cost-effective as possible.

It's largely inspired by
[TechToSpeech/terraform-aws-serverless-static-wordpress](https://github.com/TechToSpeech/terraform-aws-serverless-static-wordpress/),
but uses [AWS CDK](https://aws.amazon.com/cdk/) instead of Terraform.

It creates the infrastructure to launch a temporary, transient Wordpress container. You then log in and customize it
like any Wordpress site, and finally publish it as a static site fronted by a global CloudFront CDN and S3 Origin. When
you’re done you shut down the Wordpress container and it costs you almost nothing.

[WP2Static](https://wp2static.com/) is used to generate the static site from the Wordpress container.

## Project Status

⚠️ This project is archived and no longer being maintained. ⚠️

This was a fun side project, but recent external changes have made it challenging to run Wordpress in a cost-efficient
manner.

1. The [deprecation of AWS RDS Serverless v1](https://www.infoq.com/news/2024/01/aurora-serverless-v1-retirement/) means
   that AWS no longer offers a managed MySQL database instance that can scale to 0 when not in use. I
   [considered a few ideas](https://github.com/blimmer/cdk-static-wordpress/issues/32) to work around this, but
   ultimately I decided that the workarounds wouldn't match my personal use case.
2. [WP2Static](https://wp2static.com/) is quite slow, and [many issues](https://github.com/elementor/wp2static) go
   unaddressed. It seems like they're actively pushing their hosted / paid solution, which is fine, but it means that
   the OSS version doesn't receive much attention.
3. I couldn't find a good solution to store images and other media files in a cost-effective manner. Wordpress stores
   uploads in EFS, which is quite expensive for this use case. My primary use case was to host a travel blog with lots
   of high-quality images, so this was a significant cost factor for me.
4. Wordpress is a pain, in general. It's really a beast to maintain. I broke the docker image several times trying to
   keep the PHP / Apache dependencies up-to-date. I'm not a Wordpress expert, so I found it challenging to debug.

For these reasons, I've decided to no longer maintain this package. If anyone would like to pick up the torch and
continue maintaining this project, please feel free to fork it!

### Alternatives

* If you like the idea of this package, you could keep an eye on
  [TechToSpeech/terraform-aws-serverless-static-wordpress](https://github.com/TechToSpeech/terraform-aws-serverless-static-wordpress/).
  That project was the original inspiration for this CDK rewrite. However, that repository still uses Aurora Serverless
  V1 and hasn't received much attention lately (at time of writing - May 2024, it hasn't been updated in > 2 years).
* Consider a tool designed specifically for static site generation. For me, I migrated my project to use
  [Astro](https://astro.build). I used
  [lonekorean/wordpress-export-to-markdown](https://github.com/lonekorean/wordpress-export-to-markdown) to export my
  content from Wordpress to Markdown, and then I manually copied the exported files into my Astro project. It required a
  bit of manual translation, but it worked great for my use case. Astro is very fast compared to WP2Static (for my use
  case > 100x faster) and is designed for this use case. You can also use Astro with
  [many other CMS tools](https://docs.astro.build/en/guides/cms/) if you don't want to write Markdown.
* I've been keeping my eyes on [Webiny](https://www.webiny.com/), a truly serverless CMS tool. This didn't quite work
  for my use case, but it might work for you.

### Decommissioning your Stack

If you'd like to take a final backup, you can use a tool like
[Updraft Plus](https://wordpress.org/plugins/updraftplus/). This will create a portable backup you can use to restore
your Wordpress instance somewhere else (e.g., [Lightsail](https://aws.amazon.com/lightsail/projects/wordpress/), a
hosted Wordpress provider, etc.).

Then, destroy the resources created CDK Static Wordpress by running `cdk destroy`. This will remove all the resources
associated with the project.

## Quick Start

1. Install the construct:

   ```bash
   yarn add @blimmer/cdk-static-wordpress

   # or

   npm i --save @blimmer/cdk-static-wordpress
   ```
2. Instantiate a `StaticWordpress` instance a `Stack`:

   ```python
   import { StaticWordpress } from "@blimmer/cdk-static-wordpress";
   import { Stack, StackProps } from "aws-cdk-lib";
   import { HostedZone } from "aws-cdk-lib/aws-route53";
   import { Construct } from "constructs";

   export class StaticWordpressStack extends Stack {
     constructor(scope: Construct, id: string, props?: StackProps) {
       super(scope, id, props);

       // You can create or import a hosted zone
       // See https://docs.aws.amazon.com/cdk/api/v2/docs/aws-cdk-lib.aws_route53.HostedZone.html
       const exampleHostedZone = new HostedZone(this, "ExampleHostedZone", {
         zoneName: "example.com",
       });
       new StaticWordpress(this, "StaticWordpress", {
         fullyQualifiedSiteName: "blog.example.com",
         hostedZone: exampleHostedZone,
         wordpressAdminProps: {
           email: "me@example.com",
         },
       });
     }
   }
   ```
3. Deploy with the [`cdk deploy` command](https://docs.aws.amazon.com/cdk/v2/guide/cli.html#cli-deploy)
4. Once the deployment completes, visit the Wordpress console at `admin-<fullyQualifiedSiteName>`. E.g., if your static
   site is `blog.example.com`, visit `admin-blog.example.com/wp-admin`. The default password for the wordpress user is
   `changeme` (please change it :smile:).
5. Customize Wordpress as you see fit, create posts, etc.
6. When you're ready to deploy your static site, trigger WP2Static.

   ![](https://github.com/blimmer/cdk-static-wordpress/assets/630449/598ecdd4-ffb6-4381-bd0e-50564622f3c3)
7. Visit your static site (e.g., `blog.example.com`) once WP2Static completes.
8. (optional) Shut down the Wordpress container to save money.

   ```python
   new StaticWordpress(this, "StaticWordpress", {
     fullyQualifiedSiteName: "blog.example.com",
     hostedZone: exampleHostedZone,
     wordpressAdminProps: {
       email: "me@example.com",
       run: false, // <-- Shut down the container after deployment
     },
   });
   ```

## Architecture

TODO

## Escape Hatches

This construct provides escape hatches, to allow you to customize the underlying infrastructure if you need to. This is
a big benefit of using CDK over Terraform (where every customizable property must be manually exposed as a variable).

Look for `*Overrides` in [the API docs](/API.md) for customization options. But, be warned, we allow overriding almost
everything, so you can easily produce invalid infrastructure if you don't know what you're doing.
'''
from pkgutil import extend_path
__path__ = extend_path(__path__, __name__)

import abc
import builtins
import datetime
import enum
import typing

import jsii
import publication
import typing_extensions

from typeguard import check_type

from ._jsii import *

import aws_cdk as _aws_cdk_ceddda9d
import aws_cdk.aws_certificatemanager as _aws_cdk_aws_certificatemanager_ceddda9d
import aws_cdk.aws_cloudfront as _aws_cdk_aws_cloudfront_ceddda9d
import aws_cdk.aws_ec2 as _aws_cdk_aws_ec2_ceddda9d
import aws_cdk.aws_ecr_assets as _aws_cdk_aws_ecr_assets_ceddda9d
import aws_cdk.aws_ecs as _aws_cdk_aws_ecs_ceddda9d
import aws_cdk.aws_efs as _aws_cdk_aws_efs_ceddda9d
import aws_cdk.aws_iam as _aws_cdk_aws_iam_ceddda9d
import aws_cdk.aws_kms as _aws_cdk_aws_kms_ceddda9d
import aws_cdk.aws_rds as _aws_cdk_aws_rds_ceddda9d
import aws_cdk.aws_route53 as _aws_cdk_aws_route53_ceddda9d
import aws_cdk.aws_s3 as _aws_cdk_aws_s3_ceddda9d
import aws_cdk.aws_stepfunctions_tasks as _aws_cdk_aws_stepfunctions_tasks_ceddda9d
import constructs as _constructs_77d1e7e8


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.BehaviorOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "allowed_methods": "allowedMethods",
        "cached_methods": "cachedMethods",
        "cache_policy": "cachePolicy",
        "compress": "compress",
        "edge_lambdas": "edgeLambdas",
        "function_associations": "functionAssociations",
        "origin_request_policy": "originRequestPolicy",
        "response_headers_policy": "responseHeadersPolicy",
        "smooth_streaming": "smoothStreaming",
        "trusted_key_groups": "trustedKeyGroups",
        "viewer_protocol_policy": "viewerProtocolPolicy",
    },
)
class BehaviorOverrides:
    def __init__(
        self,
        *,
        allowed_methods: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.AllowedMethods] = None,
        cached_methods: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.CachedMethods] = None,
        cache_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ICachePolicy] = None,
        compress: typing.Optional[builtins.bool] = None,
        edge_lambdas: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.EdgeLambda, typing.Dict[builtins.str, typing.Any]]]] = None,
        function_associations: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.FunctionAssociation, typing.Dict[builtins.str, typing.Any]]]] = None,
        origin_request_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IOriginRequestPolicy] = None,
        response_headers_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IResponseHeadersPolicy] = None,
        smooth_streaming: typing.Optional[builtins.bool] = None,
        trusted_key_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_cloudfront_ceddda9d.IKeyGroup]] = None,
        viewer_protocol_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ViewerProtocolPolicy] = None,
    ) -> None:
        '''(deprecated) BehaviorOverrides.

        :param allowed_methods: HTTP methods to allow for this behavior. Default: AllowedMethods.ALLOW_GET_HEAD
        :param cached_methods: HTTP methods to cache for this behavior. Default: CachedMethods.CACHE_GET_HEAD
        :param cache_policy: The cache policy for this behavior. The cache policy determines what values are included in the cache key, and the time-to-live (TTL) values for the cache. Default: CachePolicy.CACHING_OPTIMIZED
        :param compress: Whether you want CloudFront to automatically compress certain files for this cache behavior. See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html#compressed-content-cloudfront-file-types for file types CloudFront will compress. Default: true
        :param edge_lambdas: The Lambda@Edge functions to invoke before serving the contents. Default: - no Lambda functions will be invoked
        :param function_associations: The CloudFront functions to invoke before serving the contents. Default: - no functions will be invoked
        :param origin_request_policy: The origin request policy for this behavior. The origin request policy determines which values (e.g., headers, cookies) are included in requests that CloudFront sends to the origin. Default: - none
        :param response_headers_policy: The response headers policy for this behavior. The response headers policy determines which headers are included in responses Default: - none
        :param smooth_streaming: Set this to true to indicate you want to distribute media files in the Microsoft Smooth Streaming format using this behavior. Default: false
        :param trusted_key_groups: A list of Key Groups that CloudFront can use to validate signed URLs or signed cookies. Default: - no KeyGroups are associated with cache behavior
        :param viewer_protocol_policy: The protocol that viewers can use to access the files controlled by this behavior. Default: ViewerProtocolPolicy.ALLOW_ALL

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__b1984cbbd6274b9b837c071ff4051c5ac04fd202474376359a113a873bfad77d)
            check_type(argname="argument allowed_methods", value=allowed_methods, expected_type=type_hints["allowed_methods"])
            check_type(argname="argument cached_methods", value=cached_methods, expected_type=type_hints["cached_methods"])
            check_type(argname="argument cache_policy", value=cache_policy, expected_type=type_hints["cache_policy"])
            check_type(argname="argument compress", value=compress, expected_type=type_hints["compress"])
            check_type(argname="argument edge_lambdas", value=edge_lambdas, expected_type=type_hints["edge_lambdas"])
            check_type(argname="argument function_associations", value=function_associations, expected_type=type_hints["function_associations"])
            check_type(argname="argument origin_request_policy", value=origin_request_policy, expected_type=type_hints["origin_request_policy"])
            check_type(argname="argument response_headers_policy", value=response_headers_policy, expected_type=type_hints["response_headers_policy"])
            check_type(argname="argument smooth_streaming", value=smooth_streaming, expected_type=type_hints["smooth_streaming"])
            check_type(argname="argument trusted_key_groups", value=trusted_key_groups, expected_type=type_hints["trusted_key_groups"])
            check_type(argname="argument viewer_protocol_policy", value=viewer_protocol_policy, expected_type=type_hints["viewer_protocol_policy"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if allowed_methods is not None:
            self._values["allowed_methods"] = allowed_methods
        if cached_methods is not None:
            self._values["cached_methods"] = cached_methods
        if cache_policy is not None:
            self._values["cache_policy"] = cache_policy
        if compress is not None:
            self._values["compress"] = compress
        if edge_lambdas is not None:
            self._values["edge_lambdas"] = edge_lambdas
        if function_associations is not None:
            self._values["function_associations"] = function_associations
        if origin_request_policy is not None:
            self._values["origin_request_policy"] = origin_request_policy
        if response_headers_policy is not None:
            self._values["response_headers_policy"] = response_headers_policy
        if smooth_streaming is not None:
            self._values["smooth_streaming"] = smooth_streaming
        if trusted_key_groups is not None:
            self._values["trusted_key_groups"] = trusted_key_groups
        if viewer_protocol_policy is not None:
            self._values["viewer_protocol_policy"] = viewer_protocol_policy

    @builtins.property
    def allowed_methods(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.AllowedMethods]:
        '''HTTP methods to allow for this behavior.

        :default: AllowedMethods.ALLOW_GET_HEAD
        '''
        result = self._values.get("allowed_methods")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.AllowedMethods], result)

    @builtins.property
    def cached_methods(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.CachedMethods]:
        '''HTTP methods to cache for this behavior.

        :default: CachedMethods.CACHE_GET_HEAD
        '''
        result = self._values.get("cached_methods")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.CachedMethods], result)

    @builtins.property
    def cache_policy(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ICachePolicy]:
        '''The cache policy for this behavior.

        The cache policy determines what values are included in the cache key,
        and the time-to-live (TTL) values for the cache.

        :default: CachePolicy.CACHING_OPTIMIZED
        '''
        result = self._values.get("cache_policy")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ICachePolicy], result)

    @builtins.property
    def compress(self) -> typing.Optional[builtins.bool]:
        '''Whether you want CloudFront to automatically compress certain files for this cache behavior.

        See https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/ServingCompressedFiles.html#compressed-content-cloudfront-file-types
        for file types CloudFront will compress.

        :default: true
        '''
        result = self._values.get("compress")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def edge_lambdas(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.EdgeLambda]]:
        '''The Lambda@Edge functions to invoke before serving the contents.

        :default: - no Lambda functions will be invoked
        '''
        result = self._values.get("edge_lambdas")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.EdgeLambda]], result)

    @builtins.property
    def function_associations(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.FunctionAssociation]]:
        '''The CloudFront functions to invoke before serving the contents.

        :default: - no functions will be invoked
        '''
        result = self._values.get("function_associations")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.FunctionAssociation]], result)

    @builtins.property
    def origin_request_policy(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IOriginRequestPolicy]:
        '''The origin request policy for this behavior.

        The origin request policy determines which values (e.g., headers, cookies)
        are included in requests that CloudFront sends to the origin.

        :default: - none
        '''
        result = self._values.get("origin_request_policy")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IOriginRequestPolicy], result)

    @builtins.property
    def response_headers_policy(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IResponseHeadersPolicy]:
        '''The response headers policy for this behavior.

        The response headers policy determines which headers are included in responses

        :default: - none
        '''
        result = self._values.get("response_headers_policy")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IResponseHeadersPolicy], result)

    @builtins.property
    def smooth_streaming(self) -> typing.Optional[builtins.bool]:
        '''Set this to true to indicate you want to distribute media files in the Microsoft Smooth Streaming format using this behavior.

        :default: false
        '''
        result = self._values.get("smooth_streaming")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def trusted_key_groups(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.IKeyGroup]]:
        '''A list of Key Groups that CloudFront can use to validate signed URLs or signed cookies.

        :default: - no KeyGroups are associated with cache behavior
        '''
        result = self._values.get("trusted_key_groups")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.IKeyGroup]], result)

    @builtins.property
    def viewer_protocol_policy(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ViewerProtocolPolicy]:
        '''The protocol that viewers can use to access the files controlled by this behavior.

        :default: ViewerProtocolPolicy.ALLOW_ALL
        '''
        result = self._values.get("viewer_protocol_policy")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ViewerProtocolPolicy], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "BehaviorOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.CloudFrontDistributionConfig",
    jsii_struct_bases=[],
    name_mapping={
        "behavior_overrides": "behaviorOverrides",
        "distribution_overrides": "distributionOverrides",
    },
)
class CloudFrontDistributionConfig:
    def __init__(
        self,
        *,
        behavior_overrides: typing.Optional[typing.Union[BehaviorOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        distribution_overrides: typing.Optional[typing.Union["DistributionOverrides", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param behavior_overrides: (deprecated) [ADVANCED] Override the S3 origin behaviors.
        :param distribution_overrides: (deprecated) [ADVANCED] Override properties on the CloudFront distribution (e.g., add a WAF).

        :stability: deprecated
        '''
        if isinstance(behavior_overrides, dict):
            behavior_overrides = BehaviorOverrides(**behavior_overrides)
        if isinstance(distribution_overrides, dict):
            distribution_overrides = DistributionOverrides(**distribution_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__847b4264bbac4e16ebc001d7da4cdd60ea9b319b7096a9e740e6e34ba1248757)
            check_type(argname="argument behavior_overrides", value=behavior_overrides, expected_type=type_hints["behavior_overrides"])
            check_type(argname="argument distribution_overrides", value=distribution_overrides, expected_type=type_hints["distribution_overrides"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if behavior_overrides is not None:
            self._values["behavior_overrides"] = behavior_overrides
        if distribution_overrides is not None:
            self._values["distribution_overrides"] = distribution_overrides

    @builtins.property
    def behavior_overrides(self) -> typing.Optional[BehaviorOverrides]:
        '''(deprecated) [ADVANCED] Override the S3 origin behaviors.

        :stability: deprecated
        '''
        result = self._values.get("behavior_overrides")
        return typing.cast(typing.Optional[BehaviorOverrides], result)

    @builtins.property
    def distribution_overrides(self) -> typing.Optional["DistributionOverrides"]:
        '''(deprecated) [ADVANCED] Override properties on the CloudFront distribution (e.g., add a WAF).

        :stability: deprecated
        '''
        result = self._values.get("distribution_overrides")
        return typing.cast(typing.Optional["DistributionOverrides"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "CloudFrontDistributionConfig(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.ContainerOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "command": "command",
        "container_name": "containerName",
        "cpu": "cpu",
        "disable_networking": "disableNetworking",
        "dns_search_domains": "dnsSearchDomains",
        "dns_servers": "dnsServers",
        "docker_labels": "dockerLabels",
        "docker_security_options": "dockerSecurityOptions",
        "entry_point": "entryPoint",
        "environment": "environment",
        "environment_files": "environmentFiles",
        "essential": "essential",
        "extra_hosts": "extraHosts",
        "gpu_count": "gpuCount",
        "health_check": "healthCheck",
        "hostname": "hostname",
        "image": "image",
        "inference_accelerator_resources": "inferenceAcceleratorResources",
        "linux_parameters": "linuxParameters",
        "logging": "logging",
        "memory_limit_mib": "memoryLimitMiB",
        "memory_reservation_mib": "memoryReservationMiB",
        "port_mappings": "portMappings",
        "privileged": "privileged",
        "readonly_root_filesystem": "readonlyRootFilesystem",
        "secrets": "secrets",
        "start_timeout": "startTimeout",
        "stop_timeout": "stopTimeout",
        "system_controls": "systemControls",
        "user": "user",
        "working_directory": "workingDirectory",
    },
)
class ContainerOverrides:
    def __init__(
        self,
        *,
        command: typing.Optional[typing.Sequence[builtins.str]] = None,
        container_name: typing.Optional[builtins.str] = None,
        cpu: typing.Optional[jsii.Number] = None,
        disable_networking: typing.Optional[builtins.bool] = None,
        dns_search_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
        dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
        docker_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        docker_security_options: typing.Optional[typing.Sequence[builtins.str]] = None,
        entry_point: typing.Optional[typing.Sequence[builtins.str]] = None,
        environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        environment_files: typing.Optional[typing.Sequence[_aws_cdk_aws_ecs_ceddda9d.EnvironmentFile]] = None,
        essential: typing.Optional[builtins.bool] = None,
        extra_hosts: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
        gpu_count: typing.Optional[jsii.Number] = None,
        health_check: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
        hostname: typing.Optional[builtins.str] = None,
        image: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ContainerImage] = None,
        inference_accelerator_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
        linux_parameters: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LinuxParameters] = None,
        logging: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LogDriver] = None,
        memory_limit_mib: typing.Optional[jsii.Number] = None,
        memory_reservation_mib: typing.Optional[jsii.Number] = None,
        port_mappings: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.PortMapping, typing.Dict[builtins.str, typing.Any]]]] = None,
        privileged: typing.Optional[builtins.bool] = None,
        readonly_root_filesystem: typing.Optional[builtins.bool] = None,
        secrets: typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ecs_ceddda9d.Secret]] = None,
        start_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        stop_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        system_controls: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.SystemControl, typing.Dict[builtins.str, typing.Any]]]] = None,
        user: typing.Optional[builtins.str] = None,
        working_directory: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) ContainerOverrides.

        :param command: The command that is passed to the container. If you provide a shell command as a single string, you have to quote command-line arguments. Default: - CMD value built into container image.
        :param container_name: The name of the container. Default: - id of node associated with ContainerDefinition.
        :param cpu: The minimum number of CPU units to reserve for the container. Default: - No minimum CPU units reserved.
        :param disable_networking: Specifies whether networking is disabled within the container. When this parameter is true, networking is disabled within the container. Default: false
        :param dns_search_domains: A list of DNS search domains that are presented to the container. Default: - No search domains.
        :param dns_servers: A list of DNS servers that are presented to the container. Default: - Default DNS servers.
        :param docker_labels: A key/value map of labels to add to the container. Default: - No labels.
        :param docker_security_options: A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems. Default: - No security labels.
        :param entry_point: The ENTRYPOINT value to pass to the container. Default: - Entry point configured in container.
        :param environment: The environment variables to pass to the container. Default: - No environment variables.
        :param environment_files: The environment files to pass to the container. Default: - No environment files.
        :param essential: Specifies whether the container is marked essential. If the essential parameter of a container is marked as true, and that container fails or stops for any reason, all other containers that are part of the task are stopped. If the essential parameter of a container is marked as false, then its failure does not affect the rest of the containers in a task. All tasks must have at least one essential container. If this parameter is omitted, a container is assumed to be essential. Default: true
        :param extra_hosts: A list of hostnames and IP address mappings to append to the /etc/hosts file on the container. Default: - No extra hosts.
        :param gpu_count: The number of GPUs assigned to the container. Default: - No GPUs assigned.
        :param health_check: The health check command and associated configuration parameters for the container. Default: - Health check configuration from container.
        :param hostname: The hostname to use for your container. Default: - Automatic hostname.
        :param image: The image used to start a container. This string is passed directly to the Docker daemon. Images in the Docker Hub registry are available by default. Other repositories are specified with either repository-url/image:tag or repository-url/image@digest. TODO: Update these to specify using classes of IContainerImage
        :param inference_accelerator_resources: The inference accelerators referenced by the container. Default: - No inference accelerators assigned.
        :param linux_parameters: Linux-specific modifications that are applied to the container, such as Linux kernel capabilities. For more information see `KernelCapabilities <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html>`_. Default: - No Linux parameters.
        :param logging: The log configuration specification for the container. Default: - Containers use the same logging driver that the Docker daemon uses.
        :param memory_limit_mib: The amount (in MiB) of memory to present to the container. If your container attempts to exceed the allocated memory, the container is terminated. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory limit.
        :param memory_reservation_mib: The soft limit (in MiB) of memory to reserve for the container. When system memory is under heavy contention, Docker attempts to keep the container memory to this soft limit. However, your container can consume more memory when it needs to, up to either the hard limit specified with the memory parameter (if applicable), or all of the available memory on the container instance, whichever comes first. At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services. Default: - No memory reserved.
        :param port_mappings: The port mappings to add to the container definition. Default: - No ports are mapped.
        :param privileged: Specifies whether the container is marked as privileged. When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user). Default: false
        :param readonly_root_filesystem: When this parameter is true, the container is given read-only access to its root file system. Default: false
        :param secrets: The secret environment variables to pass to the container. Default: - No secret environment variables.
        :param start_timeout: Time duration (in seconds) to wait before giving up on resolving dependencies for a container. Default: - none
        :param stop_timeout: Time duration (in seconds) to wait before the container is forcefully killed if it doesn't exit normally on its own. Default: - none
        :param system_controls: A list of namespaced kernel parameters to set in the container. Default: - No system controls are set.
        :param user: The user name to use inside the container. Default: root
        :param working_directory: The working directory in which to run commands inside the container. Default: /

        :stability: deprecated
        '''
        if isinstance(health_check, dict):
            health_check = _aws_cdk_aws_ecs_ceddda9d.HealthCheck(**health_check)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__599ff1ffc582912eda5b6283157a78a00b7d40bfcab79ea085f177161343ca90)
            check_type(argname="argument command", value=command, expected_type=type_hints["command"])
            check_type(argname="argument container_name", value=container_name, expected_type=type_hints["container_name"])
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument disable_networking", value=disable_networking, expected_type=type_hints["disable_networking"])
            check_type(argname="argument dns_search_domains", value=dns_search_domains, expected_type=type_hints["dns_search_domains"])
            check_type(argname="argument dns_servers", value=dns_servers, expected_type=type_hints["dns_servers"])
            check_type(argname="argument docker_labels", value=docker_labels, expected_type=type_hints["docker_labels"])
            check_type(argname="argument docker_security_options", value=docker_security_options, expected_type=type_hints["docker_security_options"])
            check_type(argname="argument entry_point", value=entry_point, expected_type=type_hints["entry_point"])
            check_type(argname="argument environment", value=environment, expected_type=type_hints["environment"])
            check_type(argname="argument environment_files", value=environment_files, expected_type=type_hints["environment_files"])
            check_type(argname="argument essential", value=essential, expected_type=type_hints["essential"])
            check_type(argname="argument extra_hosts", value=extra_hosts, expected_type=type_hints["extra_hosts"])
            check_type(argname="argument gpu_count", value=gpu_count, expected_type=type_hints["gpu_count"])
            check_type(argname="argument health_check", value=health_check, expected_type=type_hints["health_check"])
            check_type(argname="argument hostname", value=hostname, expected_type=type_hints["hostname"])
            check_type(argname="argument image", value=image, expected_type=type_hints["image"])
            check_type(argname="argument inference_accelerator_resources", value=inference_accelerator_resources, expected_type=type_hints["inference_accelerator_resources"])
            check_type(argname="argument linux_parameters", value=linux_parameters, expected_type=type_hints["linux_parameters"])
            check_type(argname="argument logging", value=logging, expected_type=type_hints["logging"])
            check_type(argname="argument memory_limit_mib", value=memory_limit_mib, expected_type=type_hints["memory_limit_mib"])
            check_type(argname="argument memory_reservation_mib", value=memory_reservation_mib, expected_type=type_hints["memory_reservation_mib"])
            check_type(argname="argument port_mappings", value=port_mappings, expected_type=type_hints["port_mappings"])
            check_type(argname="argument privileged", value=privileged, expected_type=type_hints["privileged"])
            check_type(argname="argument readonly_root_filesystem", value=readonly_root_filesystem, expected_type=type_hints["readonly_root_filesystem"])
            check_type(argname="argument secrets", value=secrets, expected_type=type_hints["secrets"])
            check_type(argname="argument start_timeout", value=start_timeout, expected_type=type_hints["start_timeout"])
            check_type(argname="argument stop_timeout", value=stop_timeout, expected_type=type_hints["stop_timeout"])
            check_type(argname="argument system_controls", value=system_controls, expected_type=type_hints["system_controls"])
            check_type(argname="argument user", value=user, expected_type=type_hints["user"])
            check_type(argname="argument working_directory", value=working_directory, expected_type=type_hints["working_directory"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if command is not None:
            self._values["command"] = command
        if container_name is not None:
            self._values["container_name"] = container_name
        if cpu is not None:
            self._values["cpu"] = cpu
        if disable_networking is not None:
            self._values["disable_networking"] = disable_networking
        if dns_search_domains is not None:
            self._values["dns_search_domains"] = dns_search_domains
        if dns_servers is not None:
            self._values["dns_servers"] = dns_servers
        if docker_labels is not None:
            self._values["docker_labels"] = docker_labels
        if docker_security_options is not None:
            self._values["docker_security_options"] = docker_security_options
        if entry_point is not None:
            self._values["entry_point"] = entry_point
        if environment is not None:
            self._values["environment"] = environment
        if environment_files is not None:
            self._values["environment_files"] = environment_files
        if essential is not None:
            self._values["essential"] = essential
        if extra_hosts is not None:
            self._values["extra_hosts"] = extra_hosts
        if gpu_count is not None:
            self._values["gpu_count"] = gpu_count
        if health_check is not None:
            self._values["health_check"] = health_check
        if hostname is not None:
            self._values["hostname"] = hostname
        if image is not None:
            self._values["image"] = image
        if inference_accelerator_resources is not None:
            self._values["inference_accelerator_resources"] = inference_accelerator_resources
        if linux_parameters is not None:
            self._values["linux_parameters"] = linux_parameters
        if logging is not None:
            self._values["logging"] = logging
        if memory_limit_mib is not None:
            self._values["memory_limit_mib"] = memory_limit_mib
        if memory_reservation_mib is not None:
            self._values["memory_reservation_mib"] = memory_reservation_mib
        if port_mappings is not None:
            self._values["port_mappings"] = port_mappings
        if privileged is not None:
            self._values["privileged"] = privileged
        if readonly_root_filesystem is not None:
            self._values["readonly_root_filesystem"] = readonly_root_filesystem
        if secrets is not None:
            self._values["secrets"] = secrets
        if start_timeout is not None:
            self._values["start_timeout"] = start_timeout
        if stop_timeout is not None:
            self._values["stop_timeout"] = stop_timeout
        if system_controls is not None:
            self._values["system_controls"] = system_controls
        if user is not None:
            self._values["user"] = user
        if working_directory is not None:
            self._values["working_directory"] = working_directory

    @builtins.property
    def command(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The command that is passed to the container.

        If you provide a shell command as a single string, you have to quote command-line arguments.

        :default: - CMD value built into container image.
        '''
        result = self._values.get("command")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def container_name(self) -> typing.Optional[builtins.str]:
        '''The name of the container.

        :default: - id of node associated with ContainerDefinition.
        '''
        result = self._values.get("container_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def cpu(self) -> typing.Optional[jsii.Number]:
        '''The minimum number of CPU units to reserve for the container.

        :default: - No minimum CPU units reserved.
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def disable_networking(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether networking is disabled within the container.

        When this parameter is true, networking is disabled within the container.

        :default: false
        '''
        result = self._values.get("disable_networking")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def dns_search_domains(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of DNS search domains that are presented to the container.

        :default: - No search domains.
        '''
        result = self._values.get("dns_search_domains")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def dns_servers(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of DNS servers that are presented to the container.

        :default: - Default DNS servers.
        '''
        result = self._values.get("dns_servers")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def docker_labels(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A key/value map of labels to add to the container.

        :default: - No labels.
        '''
        result = self._values.get("docker_labels")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def docker_security_options(self) -> typing.Optional[typing.List[builtins.str]]:
        '''A list of strings to provide custom labels for SELinux and AppArmor multi-level security systems.

        :default: - No security labels.
        '''
        result = self._values.get("docker_security_options")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def entry_point(self) -> typing.Optional[typing.List[builtins.str]]:
        '''The ENTRYPOINT value to pass to the container.

        :default: - Entry point configured in container.
        '''
        result = self._values.get("entry_point")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def environment(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''The environment variables to pass to the container.

        :default: - No environment variables.
        '''
        result = self._values.get("environment")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def environment_files(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.EnvironmentFile]]:
        '''The environment files to pass to the container.

        :default: - No environment files.
        '''
        result = self._values.get("environment_files")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.EnvironmentFile]], result)

    @builtins.property
    def essential(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the container is marked essential.

        If the essential parameter of a container is marked as true, and that container fails
        or stops for any reason, all other containers that are part of the task are stopped.
        If the essential parameter of a container is marked as false, then its failure does not
        affect the rest of the containers in a task. All tasks must have at least one essential container.

        If this parameter is omitted, a container is assumed to be essential.

        :default: true
        '''
        result = self._values.get("essential")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def extra_hosts(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''A list of hostnames and IP address mappings to append to the /etc/hosts file on the container.

        :default: - No extra hosts.
        '''
        result = self._values.get("extra_hosts")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    @builtins.property
    def gpu_count(self) -> typing.Optional[jsii.Number]:
        '''The number of GPUs assigned to the container.

        :default: - No GPUs assigned.
        '''
        result = self._values.get("gpu_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def health_check(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.HealthCheck]:
        '''The health check command and associated configuration parameters for the container.

        :default: - Health check configuration from container.
        '''
        result = self._values.get("health_check")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.HealthCheck], result)

    @builtins.property
    def hostname(self) -> typing.Optional[builtins.str]:
        '''The hostname to use for your container.

        :default: - Automatic hostname.
        '''
        result = self._values.get("hostname")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def image(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ContainerImage]:
        '''The image used to start a container.

        This string is passed directly to the Docker daemon.
        Images in the Docker Hub registry are available by default.
        Other repositories are specified with either repository-url/image:tag or repository-url/image@digest.
        TODO: Update these to specify using classes of IContainerImage
        '''
        result = self._values.get("image")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ContainerImage], result)

    @builtins.property
    def inference_accelerator_resources(
        self,
    ) -> typing.Optional[typing.List[builtins.str]]:
        '''The inference accelerators referenced by the container.

        :default: - No inference accelerators assigned.
        '''
        result = self._values.get("inference_accelerator_resources")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def linux_parameters(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LinuxParameters]:
        '''Linux-specific modifications that are applied to the container, such as Linux kernel capabilities.

        For more information see `KernelCapabilities <https://docs.aws.amazon.com/AmazonECS/latest/APIReference/API_KernelCapabilities.html>`_.

        :default: - No Linux parameters.
        '''
        result = self._values.get("linux_parameters")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LinuxParameters], result)

    @builtins.property
    def logging(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LogDriver]:
        '''The log configuration specification for the container.

        :default: - Containers use the same logging driver that the Docker daemon uses.
        '''
        result = self._values.get("logging")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LogDriver], result)

    @builtins.property
    def memory_limit_mib(self) -> typing.Optional[jsii.Number]:
        '''The amount (in MiB) of memory to present to the container.

        If your container attempts to exceed the allocated memory, the container
        is terminated.

        At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services.

        :default: - No memory limit.
        '''
        result = self._values.get("memory_limit_mib")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def memory_reservation_mib(self) -> typing.Optional[jsii.Number]:
        '''The soft limit (in MiB) of memory to reserve for the container.

        When system memory is under heavy contention, Docker attempts to keep the
        container memory to this soft limit. However, your container can consume more
        memory when it needs to, up to either the hard limit specified with the memory
        parameter (if applicable), or all of the available memory on the container
        instance, whichever comes first.

        At least one of memoryLimitMiB and memoryReservationMiB is required for non-Fargate services.

        :default: - No memory reserved.
        '''
        result = self._values.get("memory_reservation_mib")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def port_mappings(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.PortMapping]]:
        '''The port mappings to add to the container definition.

        :default: - No ports are mapped.
        '''
        result = self._values.get("port_mappings")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.PortMapping]], result)

    @builtins.property
    def privileged(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the container is marked as privileged.

        When this parameter is true, the container is given elevated privileges on the host container instance (similar to the root user).

        :default: false
        '''
        result = self._values.get("privileged")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def readonly_root_filesystem(self) -> typing.Optional[builtins.bool]:
        '''When this parameter is true, the container is given read-only access to its root file system.

        :default: false
        '''
        result = self._values.get("readonly_root_filesystem")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def secrets(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ecs_ceddda9d.Secret]]:
        '''The secret environment variables to pass to the container.

        :default: - No secret environment variables.
        '''
        result = self._values.get("secrets")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ecs_ceddda9d.Secret]], result)

    @builtins.property
    def start_timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''Time duration (in seconds) to wait before giving up on resolving dependencies for a container.

        :default: - none
        '''
        result = self._values.get("start_timeout")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def stop_timeout(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''Time duration (in seconds) to wait before the container is forcefully killed if it doesn't exit normally on its own.

        :default: - none
        '''
        result = self._values.get("stop_timeout")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def system_controls(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.SystemControl]]:
        '''A list of namespaced kernel parameters to set in the container.

        :default: - No system controls are set.
        '''
        result = self._values.get("system_controls")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.SystemControl]], result)

    @builtins.property
    def user(self) -> typing.Optional[builtins.str]:
        '''The user name to use inside the container.

        :default: root
        '''
        result = self._values.get("user")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def working_directory(self) -> typing.Optional[builtins.str]:
        '''The working directory in which to run commands inside the container.

        :default: /
        '''
        result = self._values.get("working_directory")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ContainerOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.DatabaseOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "backup_retention": "backupRetention",
        "cluster_identifier": "clusterIdentifier",
        "copy_tags_to_snapshot": "copyTagsToSnapshot",
        "credentials": "credentials",
        "default_database_name": "defaultDatabaseName",
        "deletion_protection": "deletionProtection",
        "enable_data_api": "enableDataApi",
        "engine": "engine",
        "parameter_group": "parameterGroup",
        "removal_policy": "removalPolicy",
        "scaling": "scaling",
        "security_groups": "securityGroups",
        "storage_encryption_key": "storageEncryptionKey",
        "subnet_group": "subnetGroup",
        "vpc": "vpc",
        "vpc_subnets": "vpcSubnets",
    },
)
class DatabaseOverrides:
    def __init__(
        self,
        *,
        backup_retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        cluster_identifier: typing.Optional[builtins.str] = None,
        copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
        credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
        default_database_name: typing.Optional[builtins.str] = None,
        deletion_protection: typing.Optional[builtins.bool] = None,
        enable_data_api: typing.Optional[builtins.bool] = None,
        engine: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterEngine] = None,
        parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
        removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
        scaling: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
        subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(deprecated) DatabaseOverrides.

        :param backup_retention: The number of days during which automatic DB snapshots are retained. Automatic backup retention cannot be disabled on serverless clusters. Must be a value from 1 day to 35 days. Default: Duration.days(1)
        :param cluster_identifier: An optional identifier for the cluster. Default: - A name is automatically generated.
        :param copy_tags_to_snapshot: Whether to copy tags to the snapshot when a snapshot is created. Default: - true
        :param credentials: Credentials for the administrative user. Default: - A username of 'admin' and SecretsManager-generated password
        :param default_database_name: Name of a database which is automatically created inside the cluster. Default: - Database is not created in cluster.
        :param deletion_protection: Indicates whether the DB cluster should have deletion protection enabled. Default: - true if removalPolicy is RETAIN, false otherwise
        :param enable_data_api: Whether to enable the Data API. Default: false
        :param engine: What kind of database to start.
        :param parameter_group: Additional parameters to pass to the database engine. Default: - no parameter group.
        :param removal_policy: The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update. Default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        :param scaling: Scaling configuration of an Aurora Serverless database cluster. Default: - Serverless cluster is automatically paused after 5 minutes of being idle. minimum capacity: 2 ACU maximum capacity: 16 ACU
        :param security_groups: Security group. Default: - a new security group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        :param storage_encryption_key: The KMS key for storage encryption. Default: - the default master key will be used for storage encryption
        :param subnet_group: Existing subnet group for the cluster. Default: - a new subnet group is created if ``vpc`` was provided. If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        :param vpc: The VPC that this Aurora Serverless cluster has been created in. Default: - the default VPC in the account and region will be used
        :param vpc_subnets: Where to place the instances within the VPC. If provided, the ``vpc`` property must also be specified. Default: - the VPC default strategy if not specified.

        :stability: deprecated
        '''
        if isinstance(scaling, dict):
            scaling = _aws_cdk_aws_rds_ceddda9d.ServerlessScalingOptions(**scaling)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__73cd7b32fe1561b0e10849db2619de64da83e6076c1d9af38e0f4383a817df14)
            check_type(argname="argument backup_retention", value=backup_retention, expected_type=type_hints["backup_retention"])
            check_type(argname="argument cluster_identifier", value=cluster_identifier, expected_type=type_hints["cluster_identifier"])
            check_type(argname="argument copy_tags_to_snapshot", value=copy_tags_to_snapshot, expected_type=type_hints["copy_tags_to_snapshot"])
            check_type(argname="argument credentials", value=credentials, expected_type=type_hints["credentials"])
            check_type(argname="argument default_database_name", value=default_database_name, expected_type=type_hints["default_database_name"])
            check_type(argname="argument deletion_protection", value=deletion_protection, expected_type=type_hints["deletion_protection"])
            check_type(argname="argument enable_data_api", value=enable_data_api, expected_type=type_hints["enable_data_api"])
            check_type(argname="argument engine", value=engine, expected_type=type_hints["engine"])
            check_type(argname="argument parameter_group", value=parameter_group, expected_type=type_hints["parameter_group"])
            check_type(argname="argument removal_policy", value=removal_policy, expected_type=type_hints["removal_policy"])
            check_type(argname="argument scaling", value=scaling, expected_type=type_hints["scaling"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument storage_encryption_key", value=storage_encryption_key, expected_type=type_hints["storage_encryption_key"])
            check_type(argname="argument subnet_group", value=subnet_group, expected_type=type_hints["subnet_group"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if backup_retention is not None:
            self._values["backup_retention"] = backup_retention
        if cluster_identifier is not None:
            self._values["cluster_identifier"] = cluster_identifier
        if copy_tags_to_snapshot is not None:
            self._values["copy_tags_to_snapshot"] = copy_tags_to_snapshot
        if credentials is not None:
            self._values["credentials"] = credentials
        if default_database_name is not None:
            self._values["default_database_name"] = default_database_name
        if deletion_protection is not None:
            self._values["deletion_protection"] = deletion_protection
        if enable_data_api is not None:
            self._values["enable_data_api"] = enable_data_api
        if engine is not None:
            self._values["engine"] = engine
        if parameter_group is not None:
            self._values["parameter_group"] = parameter_group
        if removal_policy is not None:
            self._values["removal_policy"] = removal_policy
        if scaling is not None:
            self._values["scaling"] = scaling
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if storage_encryption_key is not None:
            self._values["storage_encryption_key"] = storage_encryption_key
        if subnet_group is not None:
            self._values["subnet_group"] = subnet_group
        if vpc is not None:
            self._values["vpc"] = vpc
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def backup_retention(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The number of days during which automatic DB snapshots are retained.

        Automatic backup retention cannot be disabled on serverless clusters.
        Must be a value from 1 day to 35 days.

        :default: Duration.days(1)
        '''
        result = self._values.get("backup_retention")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def cluster_identifier(self) -> typing.Optional[builtins.str]:
        '''An optional identifier for the cluster.

        :default: - A name is automatically generated.
        '''
        result = self._values.get("cluster_identifier")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def copy_tags_to_snapshot(self) -> typing.Optional[builtins.bool]:
        '''Whether to copy tags to the snapshot when a snapshot is created.

        :default: - true
        '''
        result = self._values.get("copy_tags_to_snapshot")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def credentials(self) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials]:
        '''Credentials for the administrative user.

        :default: - A username of 'admin' and SecretsManager-generated password
        '''
        result = self._values.get("credentials")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials], result)

    @builtins.property
    def default_database_name(self) -> typing.Optional[builtins.str]:
        '''Name of a database which is automatically created inside the cluster.

        :default: - Database is not created in cluster.
        '''
        result = self._values.get("default_database_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def deletion_protection(self) -> typing.Optional[builtins.bool]:
        '''Indicates whether the DB cluster should have deletion protection enabled.

        :default: - true if removalPolicy is RETAIN, false otherwise
        '''
        result = self._values.get("deletion_protection")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_data_api(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable the Data API.

        :default: false
        '''
        result = self._values.get("enable_data_api")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def engine(self) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterEngine]:
        '''What kind of database to start.'''
        result = self._values.get("engine")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterEngine], result)

    @builtins.property
    def parameter_group(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup]:
        '''Additional parameters to pass to the database engine.

        :default: - no parameter group.
        '''
        result = self._values.get("parameter_group")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup], result)

    @builtins.property
    def removal_policy(self) -> typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy]:
        '''The removal policy to apply when the cluster and its instances are removed from the stack or replaced during an update.

        :default: - RemovalPolicy.SNAPSHOT (remove the cluster and instances, but retain a snapshot of the data)
        '''
        result = self._values.get("removal_policy")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy], result)

    @builtins.property
    def scaling(
        self,
    ) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.ServerlessScalingOptions]:
        '''Scaling configuration of an Aurora Serverless database cluster.

        :default:

        - Serverless cluster is automatically paused after 5 minutes of being idle.
        minimum capacity: 2 ACU
        maximum capacity: 16 ACU
        '''
        result = self._values.get("scaling")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.ServerlessScalingOptions], result)

    @builtins.property
    def security_groups(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
        '''Security group.

        :default:

        - a new security group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no VPC security groups will be associated with the DB cluster.
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)

    @builtins.property
    def storage_encryption_key(self) -> typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey]:
        '''The KMS key for storage encryption.

        :default: - the default master key will be used for storage encryption
        '''
        result = self._values.get("storage_encryption_key")
        return typing.cast(typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey], result)

    @builtins.property
    def subnet_group(self) -> typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup]:
        '''Existing subnet group for the cluster.

        :default:

        - a new subnet group is created if ``vpc`` was provided.
        If the ``vpc`` property was not provided, no subnet group will be associated with the DB cluster
        '''
        result = self._values.get("subnet_group")
        return typing.cast(typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
        '''The VPC that this Aurora Serverless cluster has been created in.

        :default: - the default VPC in the account and region will be used
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
        '''Where to place the instances within the VPC.

        If provided, the ``vpc`` property must also be specified.

        :default: - the VPC default strategy if not specified.
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DatabaseOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.DistributionOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "additional_behaviors": "additionalBehaviors",
        "certificate": "certificate",
        "comment": "comment",
        "default_root_object": "defaultRootObject",
        "domain_names": "domainNames",
        "enabled": "enabled",
        "enable_ipv6": "enableIpv6",
        "enable_logging": "enableLogging",
        "error_responses": "errorResponses",
        "geo_restriction": "geoRestriction",
        "http_version": "httpVersion",
        "log_bucket": "logBucket",
        "log_file_prefix": "logFilePrefix",
        "log_includes_cookies": "logIncludesCookies",
        "minimum_protocol_version": "minimumProtocolVersion",
        "price_class": "priceClass",
        "ssl_support_method": "sslSupportMethod",
        "web_acl_id": "webAclId",
    },
)
class DistributionOverrides:
    def __init__(
        self,
        *,
        additional_behaviors: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
        certificate: typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate] = None,
        comment: typing.Optional[builtins.str] = None,
        default_root_object: typing.Optional[builtins.str] = None,
        domain_names: typing.Optional[typing.Sequence[builtins.str]] = None,
        enabled: typing.Optional[builtins.bool] = None,
        enable_ipv6: typing.Optional[builtins.bool] = None,
        enable_logging: typing.Optional[builtins.bool] = None,
        error_responses: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse, typing.Dict[builtins.str, typing.Any]]]] = None,
        geo_restriction: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction] = None,
        http_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion] = None,
        log_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
        log_file_prefix: typing.Optional[builtins.str] = None,
        log_includes_cookies: typing.Optional[builtins.bool] = None,
        minimum_protocol_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol] = None,
        price_class: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass] = None,
        ssl_support_method: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod] = None,
        web_acl_id: typing.Optional[builtins.str] = None,
    ) -> None:
        '''(deprecated) DistributionOverrides.

        :param additional_behaviors: Additional behaviors for the distribution, mapped by the pathPattern that specifies which requests to apply the behavior to. Default: - no additional behaviors are added.
        :param certificate: A certificate to associate with the distribution. The certificate must be located in N. Virginia (us-east-1). Default: - the CloudFront wildcard certificate (*.cloudfront.net) will be used.
        :param comment: Any comments you want to include about the distribution. Default: - no comment
        :param default_root_object: The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution. If no default object is set, the request goes to the origin's root (e.g., example.com/). Default: - no default root object
        :param domain_names: Alternative domain names for this distribution. If you want to use your own domain name, such as www.example.com, instead of the cloudfront.net domain name, you can add an alternate domain name to your distribution. If you attach a certificate to the distribution, you must add (at least one of) the domain names of the certificate to this list. Default: - The distribution will only support the default generated name (e.g., d111111abcdef8.cloudfront.net)
        :param enabled: Enable or disable the distribution. Default: true
        :param enable_ipv6: Whether CloudFront will respond to IPv6 DNS requests with an IPv6 address. If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses. This allows viewers to submit a second request, for an IPv4 address for your distribution. Default: true
        :param enable_logging: Enable access logging for the distribution. Default: - false, unless ``logBucket`` is specified.
        :param error_responses: How CloudFront should handle requests that are not successful (e.g., PageNotFound). Default: - No custom error responses.
        :param geo_restriction: Controls the countries in which your content is distributed. Default: - No geographic restrictions
        :param http_version: Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront. For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must support server name identification (SNI). Default: HttpVersion.HTTP2
        :param log_bucket: The Amazon S3 bucket to store the access logs in. Default: - A bucket is created if ``enableLogging`` is true
        :param log_file_prefix: An optional string that you want CloudFront to prefix to the access log filenames for this distribution. Default: - no prefix
        :param log_includes_cookies: Specifies whether you want CloudFront to include cookies in access logs. Default: false
        :param minimum_protocol_version: The minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections. CloudFront serves your objects only to browsers or devices that support at least the SSL version that you specify. Default: - SecurityPolicyProtocol.TLS_V1_2_2021 if the '
        :param price_class: The price class that corresponds with the maximum price that you want to pay for CloudFront service. If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations. If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location that has the lowest latency among the edge locations in your price class. Default: PriceClass.PRICE_CLASS_ALL
        :param ssl_support_method: The SSL method CloudFront will use for your distribution. Server Name Indication (SNI) - is an extension to the TLS computer networking protocol by which a client indicates which hostname it is attempting to connect to at the start of the handshaking process. This allows a server to present multiple certificates on the same IP address and TCP port number and hence allows multiple secure (HTTPS) websites (or any other service over TLS) to be served by the same IP address without requiring all those sites to use the same certificate. CloudFront can use SNI to host multiple distributions on the same IP - which a large majority of clients will support. If your clients cannot support SNI however - CloudFront can use dedicated IPs for your distribution - but there is a prorated monthly charge for using this feature. By default, we use SNI - but you can optionally enable dedicated IPs (VIP). See the CloudFront SSL for more details about pricing : https://aws.amazon.com/cloudfront/custom-ssl-domains/ Default: SSLMethod.SNI
        :param web_acl_id: Unique identifier that specifies the AWS WAF web ACL to associate with this CloudFront distribution. To specify a web ACL created using the latest version of AWS WAF, use the ACL ARN, for example ``arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a``. To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example ``473e64fd-f30b-4765-81a0-62ad96dd167a``. Default: - No AWS Web Application Firewall web access control list (web ACL).

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__69fb7eb5e4093f7582c9efcc795424d4ac254f144850a8d24b2f033cc9a46e8a)
            check_type(argname="argument additional_behaviors", value=additional_behaviors, expected_type=type_hints["additional_behaviors"])
            check_type(argname="argument certificate", value=certificate, expected_type=type_hints["certificate"])
            check_type(argname="argument comment", value=comment, expected_type=type_hints["comment"])
            check_type(argname="argument default_root_object", value=default_root_object, expected_type=type_hints["default_root_object"])
            check_type(argname="argument domain_names", value=domain_names, expected_type=type_hints["domain_names"])
            check_type(argname="argument enabled", value=enabled, expected_type=type_hints["enabled"])
            check_type(argname="argument enable_ipv6", value=enable_ipv6, expected_type=type_hints["enable_ipv6"])
            check_type(argname="argument enable_logging", value=enable_logging, expected_type=type_hints["enable_logging"])
            check_type(argname="argument error_responses", value=error_responses, expected_type=type_hints["error_responses"])
            check_type(argname="argument geo_restriction", value=geo_restriction, expected_type=type_hints["geo_restriction"])
            check_type(argname="argument http_version", value=http_version, expected_type=type_hints["http_version"])
            check_type(argname="argument log_bucket", value=log_bucket, expected_type=type_hints["log_bucket"])
            check_type(argname="argument log_file_prefix", value=log_file_prefix, expected_type=type_hints["log_file_prefix"])
            check_type(argname="argument log_includes_cookies", value=log_includes_cookies, expected_type=type_hints["log_includes_cookies"])
            check_type(argname="argument minimum_protocol_version", value=minimum_protocol_version, expected_type=type_hints["minimum_protocol_version"])
            check_type(argname="argument price_class", value=price_class, expected_type=type_hints["price_class"])
            check_type(argname="argument ssl_support_method", value=ssl_support_method, expected_type=type_hints["ssl_support_method"])
            check_type(argname="argument web_acl_id", value=web_acl_id, expected_type=type_hints["web_acl_id"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if additional_behaviors is not None:
            self._values["additional_behaviors"] = additional_behaviors
        if certificate is not None:
            self._values["certificate"] = certificate
        if comment is not None:
            self._values["comment"] = comment
        if default_root_object is not None:
            self._values["default_root_object"] = default_root_object
        if domain_names is not None:
            self._values["domain_names"] = domain_names
        if enabled is not None:
            self._values["enabled"] = enabled
        if enable_ipv6 is not None:
            self._values["enable_ipv6"] = enable_ipv6
        if enable_logging is not None:
            self._values["enable_logging"] = enable_logging
        if error_responses is not None:
            self._values["error_responses"] = error_responses
        if geo_restriction is not None:
            self._values["geo_restriction"] = geo_restriction
        if http_version is not None:
            self._values["http_version"] = http_version
        if log_bucket is not None:
            self._values["log_bucket"] = log_bucket
        if log_file_prefix is not None:
            self._values["log_file_prefix"] = log_file_prefix
        if log_includes_cookies is not None:
            self._values["log_includes_cookies"] = log_includes_cookies
        if minimum_protocol_version is not None:
            self._values["minimum_protocol_version"] = minimum_protocol_version
        if price_class is not None:
            self._values["price_class"] = price_class
        if ssl_support_method is not None:
            self._values["ssl_support_method"] = ssl_support_method
        if web_acl_id is not None:
            self._values["web_acl_id"] = web_acl_id

    @builtins.property
    def additional_behaviors(
        self,
    ) -> typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions]]:
        '''Additional behaviors for the distribution, mapped by the pathPattern that specifies which requests to apply the behavior to.

        :default: - no additional behaviors are added.
        '''
        result = self._values.get("additional_behaviors")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions]], result)

    @builtins.property
    def certificate(
        self,
    ) -> typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate]:
        '''A certificate to associate with the distribution.

        The certificate must be located in N. Virginia (us-east-1).

        :default: - the CloudFront wildcard certificate (*.cloudfront.net) will be used.
        '''
        result = self._values.get("certificate")
        return typing.cast(typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate], result)

    @builtins.property
    def comment(self) -> typing.Optional[builtins.str]:
        '''Any comments you want to include about the distribution.

        :default: - no comment
        '''
        result = self._values.get("comment")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def default_root_object(self) -> typing.Optional[builtins.str]:
        '''The object that you want CloudFront to request from your origin (for example, index.html) when a viewer requests the root URL for your distribution. If no default object is set, the request goes to the origin's root (e.g., example.com/).

        :default: - no default root object
        '''
        result = self._values.get("default_root_object")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def domain_names(self) -> typing.Optional[typing.List[builtins.str]]:
        '''Alternative domain names for this distribution.

        If you want to use your own domain name, such as www.example.com, instead of the cloudfront.net domain name,
        you can add an alternate domain name to your distribution. If you attach a certificate to the distribution,
        you must add (at least one of) the domain names of the certificate to this list.

        :default: - The distribution will only support the default generated name (e.g., d111111abcdef8.cloudfront.net)
        '''
        result = self._values.get("domain_names")
        return typing.cast(typing.Optional[typing.List[builtins.str]], result)

    @builtins.property
    def enabled(self) -> typing.Optional[builtins.bool]:
        '''Enable or disable the distribution.

        :default: true
        '''
        result = self._values.get("enabled")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_ipv6(self) -> typing.Optional[builtins.bool]:
        '''Whether CloudFront will respond to IPv6 DNS requests with an IPv6 address.

        If you specify false, CloudFront responds to IPv6 DNS requests with the DNS response code NOERROR and with no IP addresses.
        This allows viewers to submit a second request, for an IPv4 address for your distribution.

        :default: true
        '''
        result = self._values.get("enable_ipv6")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_logging(self) -> typing.Optional[builtins.bool]:
        '''Enable access logging for the distribution.

        :default: - false, unless ``logBucket`` is specified.
        '''
        result = self._values.get("enable_logging")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def error_responses(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse]]:
        '''How CloudFront should handle requests that are not successful (e.g., PageNotFound).

        :default: - No custom error responses.
        '''
        result = self._values.get("error_responses")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse]], result)

    @builtins.property
    def geo_restriction(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction]:
        '''Controls the countries in which your content is distributed.

        :default: - No geographic restrictions
        '''
        result = self._values.get("geo_restriction")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction], result)

    @builtins.property
    def http_version(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion]:
        '''Specify the maximum HTTP version that you want viewers to use to communicate with CloudFront.

        For viewers and CloudFront to use HTTP/2, viewers must support TLS 1.2 or later, and must support server name identification (SNI).

        :default: HttpVersion.HTTP2
        '''
        result = self._values.get("http_version")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion], result)

    @builtins.property
    def log_bucket(self) -> typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket]:
        '''The Amazon S3 bucket to store the access logs in.

        :default: - A bucket is created if ``enableLogging`` is true
        '''
        result = self._values.get("log_bucket")
        return typing.cast(typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket], result)

    @builtins.property
    def log_file_prefix(self) -> typing.Optional[builtins.str]:
        '''An optional string that you want CloudFront to prefix to the access log filenames for this distribution.

        :default: - no prefix
        '''
        result = self._values.get("log_file_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def log_includes_cookies(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether you want CloudFront to include cookies in access logs.

        :default: false
        '''
        result = self._values.get("log_includes_cookies")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def minimum_protocol_version(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol]:
        '''The minimum version of the SSL protocol that you want CloudFront to use for HTTPS connections.

        CloudFront serves your objects only to browsers or devices that support at
        least the SSL version that you specify.

        :default: - SecurityPolicyProtocol.TLS_V1_2_2021 if the '

        :aws-cdk: /aws-cloudfront:defaultSecurityPolicyTLSv1.2_2021' feature flag is set; otherwise, SecurityPolicyProtocol.TLS_V1_2_2019.
        '''
        result = self._values.get("minimum_protocol_version")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol], result)

    @builtins.property
    def price_class(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass]:
        '''The price class that corresponds with the maximum price that you want to pay for CloudFront service.

        If you specify PriceClass_All, CloudFront responds to requests for your objects from all CloudFront edge locations.
        If you specify a price class other than PriceClass_All, CloudFront serves your objects from the CloudFront edge location
        that has the lowest latency among the edge locations in your price class.

        :default: PriceClass.PRICE_CLASS_ALL
        '''
        result = self._values.get("price_class")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass], result)

    @builtins.property
    def ssl_support_method(
        self,
    ) -> typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod]:
        '''The SSL method CloudFront will use for your distribution.

        Server Name Indication (SNI) - is an extension to the TLS computer networking protocol by which a client indicates
        which hostname it is attempting to connect to at the start of the handshaking process. This allows a server to present
        multiple certificates on the same IP address and TCP port number and hence allows multiple secure (HTTPS) websites
        (or any other service over TLS) to be served by the same IP address without requiring all those sites to use the same certificate.

        CloudFront can use SNI to host multiple distributions on the same IP - which a large majority of clients will support.

        If your clients cannot support SNI however - CloudFront can use dedicated IPs for your distribution - but there is a prorated monthly charge for
        using this feature. By default, we use SNI - but you can optionally enable dedicated IPs (VIP).

        See the CloudFront SSL for more details about pricing : https://aws.amazon.com/cloudfront/custom-ssl-domains/

        :default: SSLMethod.SNI
        '''
        result = self._values.get("ssl_support_method")
        return typing.cast(typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod], result)

    @builtins.property
    def web_acl_id(self) -> typing.Optional[builtins.str]:
        '''Unique identifier that specifies the AWS WAF web ACL to associate with this CloudFront distribution.

        To specify a web ACL created using the latest version of AWS WAF, use the ACL ARN, for example
        ``arn:aws:wafv2:us-east-1:123456789012:global/webacl/ExampleWebACL/473e64fd-f30b-4765-81a0-62ad96dd167a``.
        To specify a web ACL created using AWS WAF Classic, use the ACL ID, for example ``473e64fd-f30b-4765-81a0-62ad96dd167a``.

        :default: - No AWS Web Application Firewall web access control list (web ACL).
        '''
        result = self._values.get("web_acl_id")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "DistributionOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.EcsOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "container_overrides": "containerOverrides",
        "service_overrides": "serviceOverrides",
        "task_definition_overrides": "taskDefinitionOverrides",
    },
)
class EcsOverrides:
    def __init__(
        self,
        *,
        container_overrides: typing.Optional[typing.Union[_aws_cdk_aws_stepfunctions_tasks_ceddda9d.ContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        service_overrides: typing.Optional[typing.Union["ServiceOverrides", typing.Dict[builtins.str, typing.Any]]] = None,
        task_definition_overrides: typing.Optional[typing.Union["TaskDefinitionOverrides", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param container_overrides: (deprecated) [ADVANCED] Override properties on the Fargate Container.
        :param service_overrides: (deprecated) [ADVANCED] Override properties on the Fargate Service.
        :param task_definition_overrides: (deprecated) [ADVANCED] Override properties on the Fargate Task Definition.

        :stability: deprecated
        '''
        if isinstance(container_overrides, dict):
            container_overrides = _aws_cdk_aws_stepfunctions_tasks_ceddda9d.ContainerOverrides(**container_overrides)
        if isinstance(service_overrides, dict):
            service_overrides = ServiceOverrides(**service_overrides)
        if isinstance(task_definition_overrides, dict):
            task_definition_overrides = TaskDefinitionOverrides(**task_definition_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__5835441daa450071f244ce1529963cf622560cbb994707bfd6ea0bafa8e8bc60)
            check_type(argname="argument container_overrides", value=container_overrides, expected_type=type_hints["container_overrides"])
            check_type(argname="argument service_overrides", value=service_overrides, expected_type=type_hints["service_overrides"])
            check_type(argname="argument task_definition_overrides", value=task_definition_overrides, expected_type=type_hints["task_definition_overrides"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_overrides is not None:
            self._values["container_overrides"] = container_overrides
        if service_overrides is not None:
            self._values["service_overrides"] = service_overrides
        if task_definition_overrides is not None:
            self._values["task_definition_overrides"] = task_definition_overrides

    @builtins.property
    def container_overrides(
        self,
    ) -> typing.Optional[_aws_cdk_aws_stepfunctions_tasks_ceddda9d.ContainerOverrides]:
        '''(deprecated) [ADVANCED] Override properties on the Fargate Container.

        :stability: deprecated
        '''
        result = self._values.get("container_overrides")
        return typing.cast(typing.Optional[_aws_cdk_aws_stepfunctions_tasks_ceddda9d.ContainerOverrides], result)

    @builtins.property
    def service_overrides(self) -> typing.Optional["ServiceOverrides"]:
        '''(deprecated) [ADVANCED] Override properties on the Fargate Service.

        :stability: deprecated
        '''
        result = self._values.get("service_overrides")
        return typing.cast(typing.Optional["ServiceOverrides"], result)

    @builtins.property
    def task_definition_overrides(self) -> typing.Optional["TaskDefinitionOverrides"]:
        '''(deprecated) [ADVANCED] Override properties on the Fargate Task Definition.

        :stability: deprecated
        '''
        result = self._values.get("task_definition_overrides")
        return typing.cast(typing.Optional["TaskDefinitionOverrides"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class EcsTask(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@blimmer/cdk-static-wordpress.EcsTask",
):
    '''
    :stability: deprecated
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        site_id: builtins.str,
        static_hosting: "StaticHosting",
        wordpress_admin_props: typing.Union["WordpressAdminProps", typing.Dict[builtins.str, typing.Any]],
        wordpress_docker_image: "WordpressDockerImage",
        ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        wordpress_database_props: typing.Optional[typing.Union["WordpressDatabaseProps", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param fully_qualified_site_name: 
        :param hosted_zone: 
        :param site_id: 
        :param static_hosting: 
        :param wordpress_admin_props: 
        :param wordpress_docker_image: 
        :param ecs_cluster: 
        :param vpc: 
        :param wordpress_database_props: 

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__336da97d57a79070aa7f01c569cdd1ba666ad56b7ceab5361342aeaa58a2436d)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = EcsTaskProps(
            fully_qualified_site_name=fully_qualified_site_name,
            hosted_zone=hosted_zone,
            site_id=site_id,
            static_hosting=static_hosting,
            wordpress_admin_props=wordpress_admin_props,
            wordpress_docker_image=wordpress_docker_image,
            ecs_cluster=ecs_cluster,
            vpc=vpc,
            wordpress_database_props=wordpress_database_props,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="databaseCluster")
    def database_cluster(self) -> _aws_cdk_aws_rds_ceddda9d.ServerlessCluster:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_rds_ceddda9d.ServerlessCluster, jsii.get(self, "databaseCluster"))

    @builtins.property
    @jsii.member(jsii_name="fargateService")
    def fargate_service(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateService:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateService, jsii.get(self, "fargateService"))

    @builtins.property
    @jsii.member(jsii_name="fileSystem")
    def file_system(self) -> _aws_cdk_aws_efs_ceddda9d.FileSystem:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_efs_ceddda9d.FileSystem, jsii.get(self, "fileSystem"))

    @builtins.property
    @jsii.member(jsii_name="taskDefinition")
    def task_definition(self) -> _aws_cdk_aws_ecs_ceddda9d.FargateTaskDefinition:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_ecs_ceddda9d.FargateTaskDefinition, jsii.get(self, "taskDefinition"))


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.EcsTaskProps",
    jsii_struct_bases=[],
    name_mapping={
        "fully_qualified_site_name": "fullyQualifiedSiteName",
        "hosted_zone": "hostedZone",
        "site_id": "siteId",
        "static_hosting": "staticHosting",
        "wordpress_admin_props": "wordpressAdminProps",
        "wordpress_docker_image": "wordpressDockerImage",
        "ecs_cluster": "ecsCluster",
        "vpc": "vpc",
        "wordpress_database_props": "wordpressDatabaseProps",
    },
)
class EcsTaskProps:
    def __init__(
        self,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        site_id: builtins.str,
        static_hosting: "StaticHosting",
        wordpress_admin_props: typing.Union["WordpressAdminProps", typing.Dict[builtins.str, typing.Any]],
        wordpress_docker_image: "WordpressDockerImage",
        ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        wordpress_database_props: typing.Optional[typing.Union["WordpressDatabaseProps", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fully_qualified_site_name: 
        :param hosted_zone: 
        :param site_id: 
        :param static_hosting: 
        :param wordpress_admin_props: 
        :param wordpress_docker_image: 
        :param ecs_cluster: 
        :param vpc: 
        :param wordpress_database_props: 

        :stability: deprecated
        '''
        if isinstance(wordpress_admin_props, dict):
            wordpress_admin_props = WordpressAdminProps(**wordpress_admin_props)
        if isinstance(wordpress_database_props, dict):
            wordpress_database_props = WordpressDatabaseProps(**wordpress_database_props)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__950e0c1a49e60062031199dfbd8e50a498d62afb4aa28c650e5ad71bf60810fa)
            check_type(argname="argument fully_qualified_site_name", value=fully_qualified_site_name, expected_type=type_hints["fully_qualified_site_name"])
            check_type(argname="argument hosted_zone", value=hosted_zone, expected_type=type_hints["hosted_zone"])
            check_type(argname="argument site_id", value=site_id, expected_type=type_hints["site_id"])
            check_type(argname="argument static_hosting", value=static_hosting, expected_type=type_hints["static_hosting"])
            check_type(argname="argument wordpress_admin_props", value=wordpress_admin_props, expected_type=type_hints["wordpress_admin_props"])
            check_type(argname="argument wordpress_docker_image", value=wordpress_docker_image, expected_type=type_hints["wordpress_docker_image"])
            check_type(argname="argument ecs_cluster", value=ecs_cluster, expected_type=type_hints["ecs_cluster"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument wordpress_database_props", value=wordpress_database_props, expected_type=type_hints["wordpress_database_props"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fully_qualified_site_name": fully_qualified_site_name,
            "hosted_zone": hosted_zone,
            "site_id": site_id,
            "static_hosting": static_hosting,
            "wordpress_admin_props": wordpress_admin_props,
            "wordpress_docker_image": wordpress_docker_image,
        }
        if ecs_cluster is not None:
            self._values["ecs_cluster"] = ecs_cluster
        if vpc is not None:
            self._values["vpc"] = vpc
        if wordpress_database_props is not None:
            self._values["wordpress_database_props"] = wordpress_database_props

    @builtins.property
    def fully_qualified_site_name(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("fully_qualified_site_name")
        assert result is not None, "Required property 'fully_qualified_site_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def hosted_zone(self) -> _aws_cdk_aws_route53_ceddda9d.IHostedZone:
        '''
        :stability: deprecated
        '''
        result = self._values.get("hosted_zone")
        assert result is not None, "Required property 'hosted_zone' is missing"
        return typing.cast(_aws_cdk_aws_route53_ceddda9d.IHostedZone, result)

    @builtins.property
    def site_id(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("site_id")
        assert result is not None, "Required property 'site_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def static_hosting(self) -> "StaticHosting":
        '''
        :stability: deprecated
        '''
        result = self._values.get("static_hosting")
        assert result is not None, "Required property 'static_hosting' is missing"
        return typing.cast("StaticHosting", result)

    @builtins.property
    def wordpress_admin_props(self) -> "WordpressAdminProps":
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_admin_props")
        assert result is not None, "Required property 'wordpress_admin_props' is missing"
        return typing.cast("WordpressAdminProps", result)

    @builtins.property
    def wordpress_docker_image(self) -> "WordpressDockerImage":
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_docker_image")
        assert result is not None, "Required property 'wordpress_docker_image' is missing"
        return typing.cast("WordpressDockerImage", result)

    @builtins.property
    def ecs_cluster(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("ecs_cluster")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], result)

    @builtins.property
    def wordpress_database_props(self) -> typing.Optional["WordpressDatabaseProps"]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_database_props")
        return typing.cast(typing.Optional["WordpressDatabaseProps"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "EcsTaskProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.ServiceOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "assign_public_ip": "assignPublicIp",
        "capacity_provider_strategies": "capacityProviderStrategies",
        "circuit_breaker": "circuitBreaker",
        "cloud_map_options": "cloudMapOptions",
        "cluster": "cluster",
        "deployment_controller": "deploymentController",
        "desired_count": "desiredCount",
        "enable_ecs_managed_tags": "enableECSManagedTags",
        "enable_execute_command": "enableExecuteCommand",
        "health_check_grace_period": "healthCheckGracePeriod",
        "max_healthy_percent": "maxHealthyPercent",
        "min_healthy_percent": "minHealthyPercent",
        "platform_version": "platformVersion",
        "propagate_tags": "propagateTags",
        "security_groups": "securityGroups",
        "service_connect_configuration": "serviceConnectConfiguration",
        "service_name": "serviceName",
        "task_definition": "taskDefinition",
        "vpc_subnets": "vpcSubnets",
    },
)
class ServiceOverrides:
    def __init__(
        self,
        *,
        assign_public_ip: typing.Optional[builtins.bool] = None,
        capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy, typing.Dict[builtins.str, typing.Any]]]] = None,
        circuit_breaker: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker, typing.Dict[builtins.str, typing.Any]]] = None,
        cloud_map_options: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions, typing.Dict[builtins.str, typing.Any]]] = None,
        cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
        deployment_controller: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentController, typing.Dict[builtins.str, typing.Any]]] = None,
        desired_count: typing.Optional[jsii.Number] = None,
        enable_ecs_managed_tags: typing.Optional[builtins.bool] = None,
        enable_execute_command: typing.Optional[builtins.bool] = None,
        health_check_grace_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
        max_healthy_percent: typing.Optional[jsii.Number] = None,
        min_healthy_percent: typing.Optional[jsii.Number] = None,
        platform_version: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion] = None,
        propagate_tags: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource] = None,
        security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
        service_connect_configuration: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps, typing.Dict[builtins.str, typing.Any]]] = None,
        service_name: typing.Optional[builtins.str] = None,
        task_definition: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinition] = None,
        vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''(deprecated) ServiceOverrides.

        :param assign_public_ip: Specifies whether the task's elastic network interface receives a public IP address. If true, each task will receive a public IP address. Default: false
        :param capacity_provider_strategies: A list of Capacity Provider strategies used to place a service. Default: - undefined
        :param circuit_breaker: Whether to enable the deployment circuit breaker. If this property is defined, circuit breaker will be implicitly enabled. Default: - disabled
        :param cloud_map_options: The options for configuring an Amazon ECS service to use service discovery. Default: - AWS Cloud Map service discovery is not enabled.
        :param cluster: The name of the cluster that hosts the service.
        :param deployment_controller: Specifies which deployment controller to use for the service. For more information, see `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_ Default: - Rolling update (ECS)
        :param desired_count: The desired number of instantiations of the task definition to keep running on the service. Default: - When creating the service, default is 1; when updating the service, default uses the current task number.
        :param enable_ecs_managed_tags: Specifies whether to enable Amazon ECS managed tags for the tasks within the service. For more information, see `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_ Default: false
        :param enable_execute_command: Whether to enable the ability to execute into a container. Default: - undefined
        :param health_check_grace_period: The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started. Default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set
        :param max_healthy_percent: The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment. Default: - 100 if daemon, otherwise 200
        :param min_healthy_percent: The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment. Default: - 0 if daemon, otherwise 50
        :param platform_version: The platform version on which to run your service. If one is not specified, the LATEST platform version is used by default. For more information, see `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_ in the Amazon Elastic Container Service Developer Guide. Default: Latest
        :param propagate_tags: Specifies whether to propagate the tags from the task definition or the service to the tasks in the service. Valid values are: PropagatedTagSource.SERVICE, PropagatedTagSource.TASK_DEFINITION or PropagatedTagSource.NONE Default: PropagatedTagSource.NONE
        :param security_groups: The security groups to associate with the service. If you do not specify a security group, a new security group is created. Default: - A new security group is created.
        :param service_connect_configuration: Configuration for Service Connect. Default: No ports are advertised via Service Connect on this service, and the service cannot make requests to other services via Service Connect.
        :param service_name: The name of the service. Default: - CloudFormation-generated name.
        :param task_definition: The task definition to use for tasks in the service. [disable-awslint:ref-via-interface]
        :param vpc_subnets: The subnets to associate with the service. Default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.

        :stability: deprecated
        '''
        if isinstance(circuit_breaker, dict):
            circuit_breaker = _aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker(**circuit_breaker)
        if isinstance(cloud_map_options, dict):
            cloud_map_options = _aws_cdk_aws_ecs_ceddda9d.CloudMapOptions(**cloud_map_options)
        if isinstance(deployment_controller, dict):
            deployment_controller = _aws_cdk_aws_ecs_ceddda9d.DeploymentController(**deployment_controller)
        if isinstance(service_connect_configuration, dict):
            service_connect_configuration = _aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps(**service_connect_configuration)
        if isinstance(vpc_subnets, dict):
            vpc_subnets = _aws_cdk_aws_ec2_ceddda9d.SubnetSelection(**vpc_subnets)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__027188d29eba3cd79c5f3dbba120e8792c24129976efd181c9c95fb3257c99a9)
            check_type(argname="argument assign_public_ip", value=assign_public_ip, expected_type=type_hints["assign_public_ip"])
            check_type(argname="argument capacity_provider_strategies", value=capacity_provider_strategies, expected_type=type_hints["capacity_provider_strategies"])
            check_type(argname="argument circuit_breaker", value=circuit_breaker, expected_type=type_hints["circuit_breaker"])
            check_type(argname="argument cloud_map_options", value=cloud_map_options, expected_type=type_hints["cloud_map_options"])
            check_type(argname="argument cluster", value=cluster, expected_type=type_hints["cluster"])
            check_type(argname="argument deployment_controller", value=deployment_controller, expected_type=type_hints["deployment_controller"])
            check_type(argname="argument desired_count", value=desired_count, expected_type=type_hints["desired_count"])
            check_type(argname="argument enable_ecs_managed_tags", value=enable_ecs_managed_tags, expected_type=type_hints["enable_ecs_managed_tags"])
            check_type(argname="argument enable_execute_command", value=enable_execute_command, expected_type=type_hints["enable_execute_command"])
            check_type(argname="argument health_check_grace_period", value=health_check_grace_period, expected_type=type_hints["health_check_grace_period"])
            check_type(argname="argument max_healthy_percent", value=max_healthy_percent, expected_type=type_hints["max_healthy_percent"])
            check_type(argname="argument min_healthy_percent", value=min_healthy_percent, expected_type=type_hints["min_healthy_percent"])
            check_type(argname="argument platform_version", value=platform_version, expected_type=type_hints["platform_version"])
            check_type(argname="argument propagate_tags", value=propagate_tags, expected_type=type_hints["propagate_tags"])
            check_type(argname="argument security_groups", value=security_groups, expected_type=type_hints["security_groups"])
            check_type(argname="argument service_connect_configuration", value=service_connect_configuration, expected_type=type_hints["service_connect_configuration"])
            check_type(argname="argument service_name", value=service_name, expected_type=type_hints["service_name"])
            check_type(argname="argument task_definition", value=task_definition, expected_type=type_hints["task_definition"])
            check_type(argname="argument vpc_subnets", value=vpc_subnets, expected_type=type_hints["vpc_subnets"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if assign_public_ip is not None:
            self._values["assign_public_ip"] = assign_public_ip
        if capacity_provider_strategies is not None:
            self._values["capacity_provider_strategies"] = capacity_provider_strategies
        if circuit_breaker is not None:
            self._values["circuit_breaker"] = circuit_breaker
        if cloud_map_options is not None:
            self._values["cloud_map_options"] = cloud_map_options
        if cluster is not None:
            self._values["cluster"] = cluster
        if deployment_controller is not None:
            self._values["deployment_controller"] = deployment_controller
        if desired_count is not None:
            self._values["desired_count"] = desired_count
        if enable_ecs_managed_tags is not None:
            self._values["enable_ecs_managed_tags"] = enable_ecs_managed_tags
        if enable_execute_command is not None:
            self._values["enable_execute_command"] = enable_execute_command
        if health_check_grace_period is not None:
            self._values["health_check_grace_period"] = health_check_grace_period
        if max_healthy_percent is not None:
            self._values["max_healthy_percent"] = max_healthy_percent
        if min_healthy_percent is not None:
            self._values["min_healthy_percent"] = min_healthy_percent
        if platform_version is not None:
            self._values["platform_version"] = platform_version
        if propagate_tags is not None:
            self._values["propagate_tags"] = propagate_tags
        if security_groups is not None:
            self._values["security_groups"] = security_groups
        if service_connect_configuration is not None:
            self._values["service_connect_configuration"] = service_connect_configuration
        if service_name is not None:
            self._values["service_name"] = service_name
        if task_definition is not None:
            self._values["task_definition"] = task_definition
        if vpc_subnets is not None:
            self._values["vpc_subnets"] = vpc_subnets

    @builtins.property
    def assign_public_ip(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether the task's elastic network interface receives a public IP address.

        If true, each task will receive a public IP address.

        :default: false
        '''
        result = self._values.get("assign_public_ip")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def capacity_provider_strategies(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy]]:
        '''A list of Capacity Provider strategies used to place a service.

        :default: - undefined
        '''
        result = self._values.get("capacity_provider_strategies")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy]], result)

    @builtins.property
    def circuit_breaker(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker]:
        '''Whether to enable the deployment circuit breaker.

        If this property is defined, circuit breaker will be implicitly
        enabled.

        :default: - disabled
        '''
        result = self._values.get("circuit_breaker")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker], result)

    @builtins.property
    def cloud_map_options(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions]:
        '''The options for configuring an Amazon ECS service to use service discovery.

        :default: - AWS Cloud Map service discovery is not enabled.
        '''
        result = self._values.get("cloud_map_options")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions], result)

    @builtins.property
    def cluster(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster]:
        '''The name of the cluster that hosts the service.'''
        result = self._values.get("cluster")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster], result)

    @builtins.property
    def deployment_controller(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.DeploymentController]:
        '''Specifies which deployment controller to use for the service.

        For more information, see
        `Amazon ECS Deployment Types <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/deployment-types.html>`_

        :default: - Rolling update (ECS)
        '''
        result = self._values.get("deployment_controller")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.DeploymentController], result)

    @builtins.property
    def desired_count(self) -> typing.Optional[jsii.Number]:
        '''The desired number of instantiations of the task definition to keep running on the service.

        :default:

        - When creating the service, default is 1; when updating the service, default uses
        the current task number.
        '''
        result = self._values.get("desired_count")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def enable_ecs_managed_tags(self) -> typing.Optional[builtins.bool]:
        '''Specifies whether to enable Amazon ECS managed tags for the tasks within the service.

        For more information, see
        `Tagging Your Amazon ECS Resources <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-using-tags.html>`_

        :default: false
        '''
        result = self._values.get("enable_ecs_managed_tags")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def enable_execute_command(self) -> typing.Optional[builtins.bool]:
        '''Whether to enable the ability to execute into a container.

        :default: - undefined
        '''
        result = self._values.get("enable_execute_command")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def health_check_grace_period(self) -> typing.Optional[_aws_cdk_ceddda9d.Duration]:
        '''The period of time, in seconds, that the Amazon ECS service scheduler ignores unhealthy Elastic Load Balancing target health checks after a task has first started.

        :default: - defaults to 60 seconds if at least one load balancer is in-use and it is not already set
        '''
        result = self._values.get("health_check_grace_period")
        return typing.cast(typing.Optional[_aws_cdk_ceddda9d.Duration], result)

    @builtins.property
    def max_healthy_percent(self) -> typing.Optional[jsii.Number]:
        '''The maximum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that can run in a service during a deployment.

        :default: - 100 if daemon, otherwise 200
        '''
        result = self._values.get("max_healthy_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def min_healthy_percent(self) -> typing.Optional[jsii.Number]:
        '''The minimum number of tasks, specified as a percentage of the Amazon ECS service's DesiredCount value, that must continue to run and remain healthy during a deployment.

        :default: - 0 if daemon, otherwise 50
        '''
        result = self._values.get("min_healthy_percent")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def platform_version(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion]:
        '''The platform version on which to run your service.

        If one is not specified, the LATEST platform version is used by default. For more information, see
        `AWS Fargate Platform Versions <https://docs.aws.amazon.com/AmazonECS/latest/developerguide/platform_versions.html>`_
        in the Amazon Elastic Container Service Developer Guide.

        :default: Latest
        '''
        result = self._values.get("platform_version")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion], result)

    @builtins.property
    def propagate_tags(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource]:
        '''Specifies whether to propagate the tags from the task definition or the service to the tasks in the service.

        Valid values are: PropagatedTagSource.SERVICE, PropagatedTagSource.TASK_DEFINITION or PropagatedTagSource.NONE

        :default: PropagatedTagSource.NONE
        '''
        result = self._values.get("propagate_tags")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource], result)

    @builtins.property
    def security_groups(
        self,
    ) -> typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]]:
        '''The security groups to associate with the service.

        If you do not specify a security group, a new security group is created.

        :default: - A new security group is created.
        '''
        result = self._values.get("security_groups")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]], result)

    @builtins.property
    def service_connect_configuration(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps]:
        '''Configuration for Service Connect.

        :default:

        No ports are advertised via Service Connect on this service, and the service
        cannot make requests to other services via Service Connect.
        '''
        result = self._values.get("service_connect_configuration")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps], result)

    @builtins.property
    def service_name(self) -> typing.Optional[builtins.str]:
        '''The name of the service.

        :default: - CloudFormation-generated name.
        '''
        result = self._values.get("service_name")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def task_definition(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinition]:
        '''The task definition to use for tasks in the service.

        [disable-awslint:ref-via-interface]
        '''
        result = self._values.get("task_definition")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinition], result)

    @builtins.property
    def vpc_subnets(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection]:
        '''The subnets to associate with the service.

        :default: - Public subnets if ``assignPublicIp`` is set, otherwise the first available one of Private, Isolated, Public, in that order.
        '''
        result = self._values.get("vpc_subnets")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "ServiceOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StaticHosting(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@blimmer/cdk-static-wordpress.StaticHosting",
):
    '''
    :stability: deprecated
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        site_id: builtins.str,
        cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        redirects: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param fully_qualified_site_name: 
        :param hosted_zone: 
        :param site_id: 
        :param cloud_front_distribution_config: 
        :param redirects: 

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__fdb5af709ea71dc174f022c325998cdda1f85b7048c66e9964dc50f8891a64f5)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = StaticHostingProps(
            fully_qualified_site_name=fully_qualified_site_name,
            hosted_zone=hosted_zone,
            site_id=site_id,
            cloud_front_distribution_config=cloud_front_distribution_config,
            redirects=redirects,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="bucket")
    def bucket(self) -> _aws_cdk_aws_s3_ceddda9d.Bucket:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_s3_ceddda9d.Bucket, jsii.get(self, "bucket"))

    @builtins.property
    @jsii.member(jsii_name="distribution")
    def distribution(self) -> _aws_cdk_aws_cloudfront_ceddda9d.Distribution:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_cloudfront_ceddda9d.Distribution, jsii.get(self, "distribution"))


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.StaticHostingProps",
    jsii_struct_bases=[],
    name_mapping={
        "fully_qualified_site_name": "fullyQualifiedSiteName",
        "hosted_zone": "hostedZone",
        "site_id": "siteId",
        "cloud_front_distribution_config": "cloudFrontDistributionConfig",
        "redirects": "redirects",
    },
)
class StaticHostingProps:
    def __init__(
        self,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        site_id: builtins.str,
        cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        redirects: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    ) -> None:
        '''
        :param fully_qualified_site_name: 
        :param hosted_zone: 
        :param site_id: 
        :param cloud_front_distribution_config: 
        :param redirects: 

        :stability: deprecated
        '''
        if isinstance(cloud_front_distribution_config, dict):
            cloud_front_distribution_config = CloudFrontDistributionConfig(**cloud_front_distribution_config)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__4e58a4a8525a11f65e814923cb6ab06fb9cb76df734dd725a10555e5ef0566d3)
            check_type(argname="argument fully_qualified_site_name", value=fully_qualified_site_name, expected_type=type_hints["fully_qualified_site_name"])
            check_type(argname="argument hosted_zone", value=hosted_zone, expected_type=type_hints["hosted_zone"])
            check_type(argname="argument site_id", value=site_id, expected_type=type_hints["site_id"])
            check_type(argname="argument cloud_front_distribution_config", value=cloud_front_distribution_config, expected_type=type_hints["cloud_front_distribution_config"])
            check_type(argname="argument redirects", value=redirects, expected_type=type_hints["redirects"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fully_qualified_site_name": fully_qualified_site_name,
            "hosted_zone": hosted_zone,
            "site_id": site_id,
        }
        if cloud_front_distribution_config is not None:
            self._values["cloud_front_distribution_config"] = cloud_front_distribution_config
        if redirects is not None:
            self._values["redirects"] = redirects

    @builtins.property
    def fully_qualified_site_name(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("fully_qualified_site_name")
        assert result is not None, "Required property 'fully_qualified_site_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def hosted_zone(self) -> _aws_cdk_aws_route53_ceddda9d.IHostedZone:
        '''
        :stability: deprecated
        '''
        result = self._values.get("hosted_zone")
        assert result is not None, "Required property 'hosted_zone' is missing"
        return typing.cast(_aws_cdk_aws_route53_ceddda9d.IHostedZone, result)

    @builtins.property
    def site_id(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("site_id")
        assert result is not None, "Required property 'site_id' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def cloud_front_distribution_config(
        self,
    ) -> typing.Optional[CloudFrontDistributionConfig]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("cloud_front_distribution_config")
        return typing.cast(typing.Optional[CloudFrontDistributionConfig], result)

    @builtins.property
    def redirects(self) -> typing.Optional[typing.Mapping[builtins.str, builtins.str]]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("redirects")
        return typing.cast(typing.Optional[typing.Mapping[builtins.str, builtins.str]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StaticHostingProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class StaticWordpress(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@blimmer/cdk-static-wordpress.StaticWordpress",
):
    '''
    :stability: deprecated
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        wordpress_admin_props: typing.Union["WordpressAdminProps", typing.Dict[builtins.str, typing.Any]],
        cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
        site_id: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        wordpress_database_props: typing.Optional[typing.Union["WordpressDatabaseProps", typing.Dict[builtins.str, typing.Any]]] = None,
        wordpress_docker_image_props: typing.Optional[typing.Union["WordpressDockerImageProps", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param fully_qualified_site_name: (deprecated) The fully qualified site name (e.g., myblog.com or subdomain.myblog.com).
        :param hosted_zone: (deprecated) The HostedZone to use to create DNS entries for the site.
        :param wordpress_admin_props: 
        :param cloud_front_distribution_config: 
        :param ecs_cluster: (deprecated) The ECS cluster for the Wordpress admin site. Default: - a new ECS cluster will be created
        :param site_id: (deprecated) An ID to use throughout this construct to identify resources. Any non-word characters will be replaced with dashes. NOTE: if you intend to change the domain name (via ``fullyQualifiedSiteName``), you should set this ``siteId`` to a static value. Otherwise, the ``siteId`` will change when you change the site name. Default: - the ``fullyQualifiedSiteName`` will be sanitized and used
        :param vpc: (deprecated) The VPC assigned to the ``ecsCluster``. Default: - a new VPC will be created
        :param wordpress_database_props: 
        :param wordpress_docker_image_props: 

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__dd2fc1160a4ad96c3edecf2c41ed215045efabbae073ac6c254b3d2b08bb33f3)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = StaticWordpressProps(
            fully_qualified_site_name=fully_qualified_site_name,
            hosted_zone=hosted_zone,
            wordpress_admin_props=wordpress_admin_props,
            cloud_front_distribution_config=cloud_front_distribution_config,
            ecs_cluster=ecs_cluster,
            site_id=site_id,
            vpc=vpc,
            wordpress_database_props=wordpress_database_props,
            wordpress_docker_image_props=wordpress_docker_image_props,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="ecsTask")
    def ecs_task(self) -> EcsTask:
        '''
        :stability: deprecated
        '''
        return typing.cast(EcsTask, jsii.get(self, "ecsTask"))

    @builtins.property
    @jsii.member(jsii_name="staticHosting")
    def static_hosting(self) -> StaticHosting:
        '''
        :stability: deprecated
        '''
        return typing.cast(StaticHosting, jsii.get(self, "staticHosting"))

    @builtins.property
    @jsii.member(jsii_name="wordpressDockerImage")
    def wordpress_docker_image(self) -> "WordpressDockerImage":
        '''
        :stability: deprecated
        '''
        return typing.cast("WordpressDockerImage", jsii.get(self, "wordpressDockerImage"))


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.StaticWordpressProps",
    jsii_struct_bases=[],
    name_mapping={
        "fully_qualified_site_name": "fullyQualifiedSiteName",
        "hosted_zone": "hostedZone",
        "wordpress_admin_props": "wordpressAdminProps",
        "cloud_front_distribution_config": "cloudFrontDistributionConfig",
        "ecs_cluster": "ecsCluster",
        "site_id": "siteId",
        "vpc": "vpc",
        "wordpress_database_props": "wordpressDatabaseProps",
        "wordpress_docker_image_props": "wordpressDockerImageProps",
    },
)
class StaticWordpressProps:
    def __init__(
        self,
        *,
        fully_qualified_site_name: builtins.str,
        hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
        wordpress_admin_props: typing.Union["WordpressAdminProps", typing.Dict[builtins.str, typing.Any]],
        cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
        ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
        site_id: typing.Optional[builtins.str] = None,
        vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
        wordpress_database_props: typing.Optional[typing.Union["WordpressDatabaseProps", typing.Dict[builtins.str, typing.Any]]] = None,
        wordpress_docker_image_props: typing.Optional[typing.Union["WordpressDockerImageProps", typing.Dict[builtins.str, typing.Any]]] = None,
    ) -> None:
        '''
        :param fully_qualified_site_name: (deprecated) The fully qualified site name (e.g., myblog.com or subdomain.myblog.com).
        :param hosted_zone: (deprecated) The HostedZone to use to create DNS entries for the site.
        :param wordpress_admin_props: 
        :param cloud_front_distribution_config: 
        :param ecs_cluster: (deprecated) The ECS cluster for the Wordpress admin site. Default: - a new ECS cluster will be created
        :param site_id: (deprecated) An ID to use throughout this construct to identify resources. Any non-word characters will be replaced with dashes. NOTE: if you intend to change the domain name (via ``fullyQualifiedSiteName``), you should set this ``siteId`` to a static value. Otherwise, the ``siteId`` will change when you change the site name. Default: - the ``fullyQualifiedSiteName`` will be sanitized and used
        :param vpc: (deprecated) The VPC assigned to the ``ecsCluster``. Default: - a new VPC will be created
        :param wordpress_database_props: 
        :param wordpress_docker_image_props: 

        :stability: deprecated
        '''
        if isinstance(wordpress_admin_props, dict):
            wordpress_admin_props = WordpressAdminProps(**wordpress_admin_props)
        if isinstance(cloud_front_distribution_config, dict):
            cloud_front_distribution_config = CloudFrontDistributionConfig(**cloud_front_distribution_config)
        if isinstance(wordpress_database_props, dict):
            wordpress_database_props = WordpressDatabaseProps(**wordpress_database_props)
        if isinstance(wordpress_docker_image_props, dict):
            wordpress_docker_image_props = WordpressDockerImageProps(**wordpress_docker_image_props)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__c420ed92f5e98468a707cd8ba569ab19533c46331752a69967ed0b016fb29fab)
            check_type(argname="argument fully_qualified_site_name", value=fully_qualified_site_name, expected_type=type_hints["fully_qualified_site_name"])
            check_type(argname="argument hosted_zone", value=hosted_zone, expected_type=type_hints["hosted_zone"])
            check_type(argname="argument wordpress_admin_props", value=wordpress_admin_props, expected_type=type_hints["wordpress_admin_props"])
            check_type(argname="argument cloud_front_distribution_config", value=cloud_front_distribution_config, expected_type=type_hints["cloud_front_distribution_config"])
            check_type(argname="argument ecs_cluster", value=ecs_cluster, expected_type=type_hints["ecs_cluster"])
            check_type(argname="argument site_id", value=site_id, expected_type=type_hints["site_id"])
            check_type(argname="argument vpc", value=vpc, expected_type=type_hints["vpc"])
            check_type(argname="argument wordpress_database_props", value=wordpress_database_props, expected_type=type_hints["wordpress_database_props"])
            check_type(argname="argument wordpress_docker_image_props", value=wordpress_docker_image_props, expected_type=type_hints["wordpress_docker_image_props"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "fully_qualified_site_name": fully_qualified_site_name,
            "hosted_zone": hosted_zone,
            "wordpress_admin_props": wordpress_admin_props,
        }
        if cloud_front_distribution_config is not None:
            self._values["cloud_front_distribution_config"] = cloud_front_distribution_config
        if ecs_cluster is not None:
            self._values["ecs_cluster"] = ecs_cluster
        if site_id is not None:
            self._values["site_id"] = site_id
        if vpc is not None:
            self._values["vpc"] = vpc
        if wordpress_database_props is not None:
            self._values["wordpress_database_props"] = wordpress_database_props
        if wordpress_docker_image_props is not None:
            self._values["wordpress_docker_image_props"] = wordpress_docker_image_props

    @builtins.property
    def fully_qualified_site_name(self) -> builtins.str:
        '''(deprecated) The fully qualified site name (e.g., myblog.com or subdomain.myblog.com).

        :stability: deprecated
        '''
        result = self._values.get("fully_qualified_site_name")
        assert result is not None, "Required property 'fully_qualified_site_name' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def hosted_zone(self) -> _aws_cdk_aws_route53_ceddda9d.IHostedZone:
        '''(deprecated) The HostedZone to use to create DNS entries for the site.

        :stability: deprecated
        '''
        result = self._values.get("hosted_zone")
        assert result is not None, "Required property 'hosted_zone' is missing"
        return typing.cast(_aws_cdk_aws_route53_ceddda9d.IHostedZone, result)

    @builtins.property
    def wordpress_admin_props(self) -> "WordpressAdminProps":
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_admin_props")
        assert result is not None, "Required property 'wordpress_admin_props' is missing"
        return typing.cast("WordpressAdminProps", result)

    @builtins.property
    def cloud_front_distribution_config(
        self,
    ) -> typing.Optional[CloudFrontDistributionConfig]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("cloud_front_distribution_config")
        return typing.cast(typing.Optional[CloudFrontDistributionConfig], result)

    @builtins.property
    def ecs_cluster(self) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster]:
        '''(deprecated) The ECS cluster for the Wordpress admin site.

        :default: - a new ECS cluster will be created

        :stability: deprecated
        '''
        result = self._values.get("ecs_cluster")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster], result)

    @builtins.property
    def site_id(self) -> typing.Optional[builtins.str]:
        '''(deprecated) An ID to use throughout this construct to identify resources. Any non-word characters will be replaced with dashes.

        NOTE: if you intend to change the domain name (via ``fullyQualifiedSiteName``), you should set this ``siteId`` to
        a static value. Otherwise, the ``siteId`` will change when you change the site name.

        :default: - the ``fullyQualifiedSiteName`` will be sanitized and used

        :stability: deprecated
        '''
        result = self._values.get("site_id")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def vpc(self) -> typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc]:
        '''(deprecated) The VPC assigned to the ``ecsCluster``.

        :default: - a new VPC will be created

        :stability: deprecated
        '''
        result = self._values.get("vpc")
        return typing.cast(typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc], result)

    @builtins.property
    def wordpress_database_props(self) -> typing.Optional["WordpressDatabaseProps"]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_database_props")
        return typing.cast(typing.Optional["WordpressDatabaseProps"], result)

    @builtins.property
    def wordpress_docker_image_props(
        self,
    ) -> typing.Optional["WordpressDockerImageProps"]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("wordpress_docker_image_props")
        return typing.cast(typing.Optional["WordpressDockerImageProps"], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "StaticWordpressProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.TaskDefinitionOverrides",
    jsii_struct_bases=[],
    name_mapping={
        "cpu": "cpu",
        "ephemeral_storage_gib": "ephemeralStorageGiB",
        "execution_role": "executionRole",
        "family": "family",
        "memory_limit_mib": "memoryLimitMiB",
        "proxy_configuration": "proxyConfiguration",
        "runtime_platform": "runtimePlatform",
        "task_role": "taskRole",
        "volumes": "volumes",
    },
)
class TaskDefinitionOverrides:
    def __init__(
        self,
        *,
        cpu: typing.Optional[jsii.Number] = None,
        ephemeral_storage_gib: typing.Optional[jsii.Number] = None,
        execution_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        family: typing.Optional[builtins.str] = None,
        memory_limit_mib: typing.Optional[jsii.Number] = None,
        proxy_configuration: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ProxyConfiguration] = None,
        runtime_platform: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.RuntimePlatform, typing.Dict[builtins.str, typing.Any]]] = None,
        task_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
        volumes: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.Volume, typing.Dict[builtins.str, typing.Any]]]] = None,
    ) -> None:
        '''(deprecated) TaskDefinitionOverrides.

        :param cpu: The number of cpu units used by the task. For tasks using the Fargate launch type, this field is required and you must use one of the following values, which determines your range of valid values for the memory parameter: 256 (.25 vCPU) - Available memory values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) 512 (.5 vCPU) - Available memory values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) 1024 (1 vCPU) - Available memory values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) 2048 (2 vCPU) - Available memory values: Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) 4096 (4 vCPU) - Available memory values: Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) 8192 (8 vCPU) - Available memory values: Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) 16384 (16 vCPU) - Available memory values: Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) Default: 256
        :param ephemeral_storage_gib: The amount (in GiB) of ephemeral storage to be allocated to the task. The maximum supported value is 200 GiB. NOTE: This parameter is only supported for tasks hosted on AWS Fargate using platform version 1.4.0 or later. Default: 20
        :param execution_role: The name of the IAM task execution role that grants the ECS agent permission to call AWS APIs on your behalf. The role will be used to retrieve container images from ECR and create CloudWatch log groups. Default: - An execution role will be automatically created if you use ECR images in your task definition.
        :param family: The name of a family that this task definition is registered to. A family groups multiple versions of a task definition. Default: - Automatically generated name.
        :param memory_limit_mib: The amount (in MiB) of memory used by the task. For tasks using the Fargate launch type, this field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU) 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU) 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU) Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU) Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU) Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU) Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU) Default: 512
        :param proxy_configuration: The configuration details for the App Mesh proxy. Default: - No proxy configuration.
        :param runtime_platform: The operating system that your task definitions are running on. A runtimePlatform is supported only for tasks using the Fargate launch type. Default: - Undefined.
        :param task_role: The name of the IAM role that grants containers in the task permission to call AWS APIs on your behalf. Default: - A task role is automatically created for you.
        :param volumes: The list of volume definitions for the task. For more information, see `Task Definition Parameter Volumes <https://docs.aws.amazon.com/AmazonECS/latest/developerguide//task_definition_parameters.html#volumes>`_. Default: - No volumes are passed to the Docker daemon on a container instance.

        :stability: deprecated
        '''
        if isinstance(runtime_platform, dict):
            runtime_platform = _aws_cdk_aws_ecs_ceddda9d.RuntimePlatform(**runtime_platform)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__ef07f9fa7c26eb0238f2a69e33ab4d84cb09fccd5d145569a1fcfb7c413627e8)
            check_type(argname="argument cpu", value=cpu, expected_type=type_hints["cpu"])
            check_type(argname="argument ephemeral_storage_gib", value=ephemeral_storage_gib, expected_type=type_hints["ephemeral_storage_gib"])
            check_type(argname="argument execution_role", value=execution_role, expected_type=type_hints["execution_role"])
            check_type(argname="argument family", value=family, expected_type=type_hints["family"])
            check_type(argname="argument memory_limit_mib", value=memory_limit_mib, expected_type=type_hints["memory_limit_mib"])
            check_type(argname="argument proxy_configuration", value=proxy_configuration, expected_type=type_hints["proxy_configuration"])
            check_type(argname="argument runtime_platform", value=runtime_platform, expected_type=type_hints["runtime_platform"])
            check_type(argname="argument task_role", value=task_role, expected_type=type_hints["task_role"])
            check_type(argname="argument volumes", value=volumes, expected_type=type_hints["volumes"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if cpu is not None:
            self._values["cpu"] = cpu
        if ephemeral_storage_gib is not None:
            self._values["ephemeral_storage_gib"] = ephemeral_storage_gib
        if execution_role is not None:
            self._values["execution_role"] = execution_role
        if family is not None:
            self._values["family"] = family
        if memory_limit_mib is not None:
            self._values["memory_limit_mib"] = memory_limit_mib
        if proxy_configuration is not None:
            self._values["proxy_configuration"] = proxy_configuration
        if runtime_platform is not None:
            self._values["runtime_platform"] = runtime_platform
        if task_role is not None:
            self._values["task_role"] = task_role
        if volumes is not None:
            self._values["volumes"] = volumes

    @builtins.property
    def cpu(self) -> typing.Optional[jsii.Number]:
        '''The number of cpu units used by the task.

        For tasks using the Fargate launch type,
        this field is required and you must use one of the following values,
        which determines your range of valid values for the memory parameter:

        256 (.25 vCPU) - Available memory values: 512 (0.5 GB), 1024 (1 GB), 2048 (2 GB)

        512 (.5 vCPU) - Available memory values: 1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB)

        1024 (1 vCPU) - Available memory values: 2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB)

        2048 (2 vCPU) - Available memory values: Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB)

        4096 (4 vCPU) - Available memory values: Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB)

        8192 (8 vCPU) - Available memory values: Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB)

        16384 (16 vCPU) - Available memory values: Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB)

        :default: 256
        '''
        result = self._values.get("cpu")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def ephemeral_storage_gib(self) -> typing.Optional[jsii.Number]:
        '''The amount (in GiB) of ephemeral storage to be allocated to the task. The maximum supported value is 200 GiB.

        NOTE: This parameter is only supported for tasks hosted on AWS Fargate using platform version 1.4.0 or later.

        :default: 20
        '''
        result = self._values.get("ephemeral_storage_gib")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def execution_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
        '''The name of the IAM task execution role that grants the ECS agent permission to call AWS APIs on your behalf.

        The role will be used to retrieve container images from ECR and create CloudWatch log groups.

        :default: - An execution role will be automatically created if you use ECR images in your task definition.
        '''
        result = self._values.get("execution_role")
        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)

    @builtins.property
    def family(self) -> typing.Optional[builtins.str]:
        '''The name of a family that this task definition is registered to.

        A family groups multiple versions of a task definition.

        :default: - Automatically generated name.
        '''
        result = self._values.get("family")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def memory_limit_mib(self) -> typing.Optional[jsii.Number]:
        '''The amount (in MiB) of memory used by the task.

        For tasks using the Fargate launch type,
        this field is required and you must use one of the following values, which determines your range of valid values for the cpu parameter:

        512 (0.5 GB), 1024 (1 GB), 2048 (2 GB) - Available cpu values: 256 (.25 vCPU)

        1024 (1 GB), 2048 (2 GB), 3072 (3 GB), 4096 (4 GB) - Available cpu values: 512 (.5 vCPU)

        2048 (2 GB), 3072 (3 GB), 4096 (4 GB), 5120 (5 GB), 6144 (6 GB), 7168 (7 GB), 8192 (8 GB) - Available cpu values: 1024 (1 vCPU)

        Between 4096 (4 GB) and 16384 (16 GB) in increments of 1024 (1 GB) - Available cpu values: 2048 (2 vCPU)

        Between 8192 (8 GB) and 30720 (30 GB) in increments of 1024 (1 GB) - Available cpu values: 4096 (4 vCPU)

        Between 16384 (16 GB) and 61440 (60 GB) in increments of 4096 (4 GB) - Available cpu values: 8192 (8 vCPU)

        Between 32768 (32 GB) and 122880 (120 GB) in increments of 8192 (8 GB) - Available cpu values: 16384 (16 vCPU)

        :default: 512
        '''
        result = self._values.get("memory_limit_mib")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def proxy_configuration(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ProxyConfiguration]:
        '''The configuration details for the App Mesh proxy.

        :default: - No proxy configuration.
        '''
        result = self._values.get("proxy_configuration")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ProxyConfiguration], result)

    @builtins.property
    def runtime_platform(
        self,
    ) -> typing.Optional[_aws_cdk_aws_ecs_ceddda9d.RuntimePlatform]:
        '''The operating system that your task definitions are running on.

        A runtimePlatform is supported only for tasks using the Fargate launch type.

        :default: - Undefined.
        '''
        result = self._values.get("runtime_platform")
        return typing.cast(typing.Optional[_aws_cdk_aws_ecs_ceddda9d.RuntimePlatform], result)

    @builtins.property
    def task_role(self) -> typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole]:
        '''The name of the IAM role that grants containers in the task permission to call AWS APIs on your behalf.

        :default: - A task role is automatically created for you.
        '''
        result = self._values.get("task_role")
        return typing.cast(typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole], result)

    @builtins.property
    def volumes(self) -> typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.Volume]]:
        '''The list of volume definitions for the task.

        For more information, see
        `Task Definition Parameter Volumes <https://docs.aws.amazon.com/AmazonECS/latest/developerguide//task_definition_parameters.html#volumes>`_.

        :default: - No volumes are passed to the Docker daemon on a container instance.
        '''
        result = self._values.get("volumes")
        return typing.cast(typing.Optional[typing.List[_aws_cdk_aws_ecs_ceddda9d.Volume]], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "TaskDefinitionOverrides(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.WordpressAdminProps",
    jsii_struct_bases=[],
    name_mapping={
        "email": "email",
        "domain_prefix": "domainPrefix",
        "ecs_overrides": "ecsOverrides",
        "password": "password",
        "run": "run",
        "username": "username",
    },
)
class WordpressAdminProps:
    def __init__(
        self,
        *,
        email: builtins.str,
        domain_prefix: typing.Optional[builtins.str] = None,
        ecs_overrides: typing.Optional[typing.Union[EcsOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        password: typing.Optional[builtins.str] = None,
        run: typing.Optional[builtins.bool] = None,
        username: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param email: 
        :param domain_prefix: (deprecated) The prefix to use for the non-static admin site. For example, if your static site is foo.example.com and you pass ``-admin`` here, the admin site will be served at admin-foo.example.com. Default: - "admin-"
        :param ecs_overrides: (deprecated) [ADVANCED] Override various aspects of the ECS infrastructure.
        :param password: (deprecated) The password to use for the admin user. Default: - changeme
        :param run: (deprecated) Should we run the Wordpress admin console? Set this to ``false`` to save money when you're not actively editing the site. Default: true
        :param username: 

        :stability: deprecated
        '''
        if isinstance(ecs_overrides, dict):
            ecs_overrides = EcsOverrides(**ecs_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__12958bbeb6a92f2fb3977ebb70c5fda7295edc247aaafd0b4d536120017faaae)
            check_type(argname="argument email", value=email, expected_type=type_hints["email"])
            check_type(argname="argument domain_prefix", value=domain_prefix, expected_type=type_hints["domain_prefix"])
            check_type(argname="argument ecs_overrides", value=ecs_overrides, expected_type=type_hints["ecs_overrides"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument run", value=run, expected_type=type_hints["run"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {
            "email": email,
        }
        if domain_prefix is not None:
            self._values["domain_prefix"] = domain_prefix
        if ecs_overrides is not None:
            self._values["ecs_overrides"] = ecs_overrides
        if password is not None:
            self._values["password"] = password
        if run is not None:
            self._values["run"] = run
        if username is not None:
            self._values["username"] = username

    @builtins.property
    def email(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        result = self._values.get("email")
        assert result is not None, "Required property 'email' is missing"
        return typing.cast(builtins.str, result)

    @builtins.property
    def domain_prefix(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The prefix to use for the non-static admin site.

        For example, if your static site is
        foo.example.com and you pass ``-admin`` here, the admin site will be served at admin-foo.example.com.

        :default: - "admin-"

        :stability: deprecated
        '''
        result = self._values.get("domain_prefix")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def ecs_overrides(self) -> typing.Optional[EcsOverrides]:
        '''(deprecated) [ADVANCED] Override various aspects of the ECS infrastructure.

        :stability: deprecated
        '''
        result = self._values.get("ecs_overrides")
        return typing.cast(typing.Optional[EcsOverrides], result)

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The password to use for the admin user.

        :default: - changeme

        :stability: deprecated
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def run(self) -> typing.Optional[builtins.bool]:
        '''(deprecated) Should we run the Wordpress admin console?

        Set this to ``false`` to save money when you're not actively editing
        the site.

        :default: true

        :stability: deprecated
        '''
        result = self._values.get("run")
        return typing.cast(typing.Optional[builtins.bool], result)

    @builtins.property
    def username(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("username")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WordpressAdminProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.WordpressDatabaseProps",
    jsii_struct_bases=[],
    name_mapping={
        "database_overrides": "databaseOverrides",
        "password": "password",
        "username": "username",
    },
)
class WordpressDatabaseProps:
    def __init__(
        self,
        *,
        database_overrides: typing.Optional[typing.Union[DatabaseOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
        password: typing.Optional[builtins.str] = None,
        username: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param database_overrides: (deprecated) [ADVANCED] Override properties on the Serverless Database Cluster.
        :param password: 
        :param username: 

        :stability: deprecated
        '''
        if isinstance(database_overrides, dict):
            database_overrides = DatabaseOverrides(**database_overrides)
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__51ed18e24d8910c7a23c095d16dc64c07cb1c3864ee25e5115c97150899078a7)
            check_type(argname="argument database_overrides", value=database_overrides, expected_type=type_hints["database_overrides"])
            check_type(argname="argument password", value=password, expected_type=type_hints["password"])
            check_type(argname="argument username", value=username, expected_type=type_hints["username"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if database_overrides is not None:
            self._values["database_overrides"] = database_overrides
        if password is not None:
            self._values["password"] = password
        if username is not None:
            self._values["username"] = username

    @builtins.property
    def database_overrides(self) -> typing.Optional[DatabaseOverrides]:
        '''(deprecated) [ADVANCED] Override properties on the Serverless Database Cluster.

        :stability: deprecated
        '''
        result = self._values.get("database_overrides")
        return typing.cast(typing.Optional[DatabaseOverrides], result)

    @builtins.property
    def password(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("password")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def username(self) -> typing.Optional[builtins.str]:
        '''
        :stability: deprecated
        '''
        result = self._values.get("username")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WordpressDatabaseProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


class WordpressDockerImage(
    _constructs_77d1e7e8.Construct,
    metaclass=jsii.JSIIMeta,
    jsii_type="@blimmer/cdk-static-wordpress.WordpressDockerImage",
):
    '''
    :stability: deprecated
    '''

    def __init__(
        self,
        scope: _constructs_77d1e7e8.Construct,
        id: builtins.str,
        *,
        container_cpu: typing.Optional[jsii.Number] = None,
        container_memory: typing.Optional[jsii.Number] = None,
        wordpress_docker_image_base: typing.Optional[builtins.str] = None,
        wordpress_memory_limit: typing.Optional[builtins.str] = None,
        wp2_static_s3_addon_version: typing.Optional[builtins.str] = None,
        wp2_static_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param scope: -
        :param id: -
        :param container_cpu: (deprecated) The number of vCPU units to give the ECS container at runtime. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-cpu for details on available configurations Default: - 256 (0.25 vCPU)
        :param container_memory: (deprecated) Memory to give the ECS container at runtime. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-memory for details on available configurations Default: - 512 (MB)
        :param wordpress_docker_image_base: Default: - wordpress:php8.0-apache
        :param wordpress_memory_limit: (deprecated) This configures how much memory is given to Wordpress. It's different than container memory, which is configured by ``containerMemory``. See https://developer.wordpress.org/apis/wp-config-php/#increasing-memory-allocated-to-php for details on this setting. Default: - 256M
        :param wp2_static_s3_addon_version: Default: - 1.0
        :param wp2_static_version: (deprecated) The version of wp2static to install. See https://github.com/WP2Static/wp2static/releases for available version Default: - 7.2

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__aae0b4436edf3a96a8116dd877888ed1b78fcabcd44330904671d670c294e75f)
            check_type(argname="argument scope", value=scope, expected_type=type_hints["scope"])
            check_type(argname="argument id", value=id, expected_type=type_hints["id"])
        props = WordpressDockerImageProps(
            container_cpu=container_cpu,
            container_memory=container_memory,
            wordpress_docker_image_base=wordpress_docker_image_base,
            wordpress_memory_limit=wordpress_memory_limit,
            wp2_static_s3_addon_version=wp2_static_s3_addon_version,
            wp2_static_version=wp2_static_version,
        )

        jsii.create(self.__class__, self, [scope, id, props])

    @builtins.property
    @jsii.member(jsii_name="containerCpu")
    def container_cpu(self) -> jsii.Number:
        '''
        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "containerCpu"))

    @builtins.property
    @jsii.member(jsii_name="containerMemory")
    def container_memory(self) -> jsii.Number:
        '''
        :stability: deprecated
        '''
        return typing.cast(jsii.Number, jsii.get(self, "containerMemory"))

    @builtins.property
    @jsii.member(jsii_name="dockerImageAsset")
    def docker_image_asset(self) -> _aws_cdk_aws_ecr_assets_ceddda9d.DockerImageAsset:
        '''
        :stability: deprecated
        '''
        return typing.cast(_aws_cdk_aws_ecr_assets_ceddda9d.DockerImageAsset, jsii.get(self, "dockerImageAsset"))

    @builtins.property
    @jsii.member(jsii_name="wordpressMemoryLimit")
    def wordpress_memory_limit(self) -> builtins.str:
        '''
        :stability: deprecated
        '''
        return typing.cast(builtins.str, jsii.get(self, "wordpressMemoryLimit"))


@jsii.data_type(
    jsii_type="@blimmer/cdk-static-wordpress.WordpressDockerImageProps",
    jsii_struct_bases=[],
    name_mapping={
        "container_cpu": "containerCpu",
        "container_memory": "containerMemory",
        "wordpress_docker_image_base": "wordpressDockerImageBase",
        "wordpress_memory_limit": "wordpressMemoryLimit",
        "wp2_static_s3_addon_version": "wp2StaticS3AddonVersion",
        "wp2_static_version": "wp2StaticVersion",
    },
)
class WordpressDockerImageProps:
    def __init__(
        self,
        *,
        container_cpu: typing.Optional[jsii.Number] = None,
        container_memory: typing.Optional[jsii.Number] = None,
        wordpress_docker_image_base: typing.Optional[builtins.str] = None,
        wordpress_memory_limit: typing.Optional[builtins.str] = None,
        wp2_static_s3_addon_version: typing.Optional[builtins.str] = None,
        wp2_static_version: typing.Optional[builtins.str] = None,
    ) -> None:
        '''
        :param container_cpu: (deprecated) The number of vCPU units to give the ECS container at runtime. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-cpu for details on available configurations Default: - 256 (0.25 vCPU)
        :param container_memory: (deprecated) Memory to give the ECS container at runtime. See https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-memory for details on available configurations Default: - 512 (MB)
        :param wordpress_docker_image_base: Default: - wordpress:php8.0-apache
        :param wordpress_memory_limit: (deprecated) This configures how much memory is given to Wordpress. It's different than container memory, which is configured by ``containerMemory``. See https://developer.wordpress.org/apis/wp-config-php/#increasing-memory-allocated-to-php for details on this setting. Default: - 256M
        :param wp2_static_s3_addon_version: Default: - 1.0
        :param wp2_static_version: (deprecated) The version of wp2static to install. See https://github.com/WP2Static/wp2static/releases for available version Default: - 7.2

        :stability: deprecated
        '''
        if __debug__:
            type_hints = typing.get_type_hints(_typecheckingstub__1189129bfa0fbc7a19851bb9e547d015c96ad47f3ec32df85a06a19b2a55189f)
            check_type(argname="argument container_cpu", value=container_cpu, expected_type=type_hints["container_cpu"])
            check_type(argname="argument container_memory", value=container_memory, expected_type=type_hints["container_memory"])
            check_type(argname="argument wordpress_docker_image_base", value=wordpress_docker_image_base, expected_type=type_hints["wordpress_docker_image_base"])
            check_type(argname="argument wordpress_memory_limit", value=wordpress_memory_limit, expected_type=type_hints["wordpress_memory_limit"])
            check_type(argname="argument wp2_static_s3_addon_version", value=wp2_static_s3_addon_version, expected_type=type_hints["wp2_static_s3_addon_version"])
            check_type(argname="argument wp2_static_version", value=wp2_static_version, expected_type=type_hints["wp2_static_version"])
        self._values: typing.Dict[builtins.str, typing.Any] = {}
        if container_cpu is not None:
            self._values["container_cpu"] = container_cpu
        if container_memory is not None:
            self._values["container_memory"] = container_memory
        if wordpress_docker_image_base is not None:
            self._values["wordpress_docker_image_base"] = wordpress_docker_image_base
        if wordpress_memory_limit is not None:
            self._values["wordpress_memory_limit"] = wordpress_memory_limit
        if wp2_static_s3_addon_version is not None:
            self._values["wp2_static_s3_addon_version"] = wp2_static_s3_addon_version
        if wp2_static_version is not None:
            self._values["wp2_static_version"] = wp2_static_version

    @builtins.property
    def container_cpu(self) -> typing.Optional[jsii.Number]:
        '''(deprecated) The number of vCPU units to give the ECS container at runtime.

        See
        https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-cpu
        for details on available configurations

        :default: - 256 (0.25 vCPU)

        :stability: deprecated
        '''
        result = self._values.get("container_cpu")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def container_memory(self) -> typing.Optional[jsii.Number]:
        '''(deprecated) Memory to give the ECS container at runtime.

        See
        https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/aws-resource-ecs-taskdefinition.html#cfn-ecs-taskdefinition-memory
        for details on available configurations

        :default: - 512 (MB)

        :stability: deprecated
        '''
        result = self._values.get("container_memory")
        return typing.cast(typing.Optional[jsii.Number], result)

    @builtins.property
    def wordpress_docker_image_base(self) -> typing.Optional[builtins.str]:
        '''
        :default: - wordpress:php8.0-apache

        :stability: deprecated
        '''
        result = self._values.get("wordpress_docker_image_base")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wordpress_memory_limit(self) -> typing.Optional[builtins.str]:
        '''(deprecated) This configures how much memory is given to Wordpress.

        It's different than container memory,
        which is configured by ``containerMemory``. See
        https://developer.wordpress.org/apis/wp-config-php/#increasing-memory-allocated-to-php
        for details on this setting.

        :default: - 256M

        :stability: deprecated
        '''
        result = self._values.get("wordpress_memory_limit")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wp2_static_s3_addon_version(self) -> typing.Optional[builtins.str]:
        '''
        :default: - 1.0

        :stability: deprecated
        '''
        result = self._values.get("wp2_static_s3_addon_version")
        return typing.cast(typing.Optional[builtins.str], result)

    @builtins.property
    def wp2_static_version(self) -> typing.Optional[builtins.str]:
        '''(deprecated) The version of wp2static to install.

        See
        https://github.com/WP2Static/wp2static/releases for available version

        :default: - 7.2

        :stability: deprecated
        '''
        result = self._values.get("wp2_static_version")
        return typing.cast(typing.Optional[builtins.str], result)

    def __eq__(self, rhs: typing.Any) -> builtins.bool:
        return isinstance(rhs, self.__class__) and rhs._values == self._values

    def __ne__(self, rhs: typing.Any) -> builtins.bool:
        return not (rhs == self)

    def __repr__(self) -> str:
        return "WordpressDockerImageProps(%s)" % ", ".join(
            k + "=" + repr(v) for k, v in self._values.items()
        )


__all__ = [
    "BehaviorOverrides",
    "CloudFrontDistributionConfig",
    "ContainerOverrides",
    "DatabaseOverrides",
    "DistributionOverrides",
    "EcsOverrides",
    "EcsTask",
    "EcsTaskProps",
    "ServiceOverrides",
    "StaticHosting",
    "StaticHostingProps",
    "StaticWordpress",
    "StaticWordpressProps",
    "TaskDefinitionOverrides",
    "WordpressAdminProps",
    "WordpressDatabaseProps",
    "WordpressDockerImage",
    "WordpressDockerImageProps",
]

publication.publish()

def _typecheckingstub__b1984cbbd6274b9b837c071ff4051c5ac04fd202474376359a113a873bfad77d(
    *,
    allowed_methods: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.AllowedMethods] = None,
    cached_methods: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.CachedMethods] = None,
    cache_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ICachePolicy] = None,
    compress: typing.Optional[builtins.bool] = None,
    edge_lambdas: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.EdgeLambda, typing.Dict[builtins.str, typing.Any]]]] = None,
    function_associations: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.FunctionAssociation, typing.Dict[builtins.str, typing.Any]]]] = None,
    origin_request_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IOriginRequestPolicy] = None,
    response_headers_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.IResponseHeadersPolicy] = None,
    smooth_streaming: typing.Optional[builtins.bool] = None,
    trusted_key_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_cloudfront_ceddda9d.IKeyGroup]] = None,
    viewer_protocol_policy: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.ViewerProtocolPolicy] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__847b4264bbac4e16ebc001d7da4cdd60ea9b319b7096a9e740e6e34ba1248757(
    *,
    behavior_overrides: typing.Optional[typing.Union[BehaviorOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    distribution_overrides: typing.Optional[typing.Union[DistributionOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__599ff1ffc582912eda5b6283157a78a00b7d40bfcab79ea085f177161343ca90(
    *,
    command: typing.Optional[typing.Sequence[builtins.str]] = None,
    container_name: typing.Optional[builtins.str] = None,
    cpu: typing.Optional[jsii.Number] = None,
    disable_networking: typing.Optional[builtins.bool] = None,
    dns_search_domains: typing.Optional[typing.Sequence[builtins.str]] = None,
    dns_servers: typing.Optional[typing.Sequence[builtins.str]] = None,
    docker_labels: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    docker_security_options: typing.Optional[typing.Sequence[builtins.str]] = None,
    entry_point: typing.Optional[typing.Sequence[builtins.str]] = None,
    environment: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    environment_files: typing.Optional[typing.Sequence[_aws_cdk_aws_ecs_ceddda9d.EnvironmentFile]] = None,
    essential: typing.Optional[builtins.bool] = None,
    extra_hosts: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
    gpu_count: typing.Optional[jsii.Number] = None,
    health_check: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.HealthCheck, typing.Dict[builtins.str, typing.Any]]] = None,
    hostname: typing.Optional[builtins.str] = None,
    image: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ContainerImage] = None,
    inference_accelerator_resources: typing.Optional[typing.Sequence[builtins.str]] = None,
    linux_parameters: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LinuxParameters] = None,
    logging: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.LogDriver] = None,
    memory_limit_mib: typing.Optional[jsii.Number] = None,
    memory_reservation_mib: typing.Optional[jsii.Number] = None,
    port_mappings: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.PortMapping, typing.Dict[builtins.str, typing.Any]]]] = None,
    privileged: typing.Optional[builtins.bool] = None,
    readonly_root_filesystem: typing.Optional[builtins.bool] = None,
    secrets: typing.Optional[typing.Mapping[builtins.str, _aws_cdk_aws_ecs_ceddda9d.Secret]] = None,
    start_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    stop_timeout: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    system_controls: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.SystemControl, typing.Dict[builtins.str, typing.Any]]]] = None,
    user: typing.Optional[builtins.str] = None,
    working_directory: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__73cd7b32fe1561b0e10849db2619de64da83e6076c1d9af38e0f4383a817df14(
    *,
    backup_retention: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    cluster_identifier: typing.Optional[builtins.str] = None,
    copy_tags_to_snapshot: typing.Optional[builtins.bool] = None,
    credentials: typing.Optional[_aws_cdk_aws_rds_ceddda9d.Credentials] = None,
    default_database_name: typing.Optional[builtins.str] = None,
    deletion_protection: typing.Optional[builtins.bool] = None,
    enable_data_api: typing.Optional[builtins.bool] = None,
    engine: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IClusterEngine] = None,
    parameter_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.IParameterGroup] = None,
    removal_policy: typing.Optional[_aws_cdk_ceddda9d.RemovalPolicy] = None,
    scaling: typing.Optional[typing.Union[_aws_cdk_aws_rds_ceddda9d.ServerlessScalingOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    storage_encryption_key: typing.Optional[_aws_cdk_aws_kms_ceddda9d.IKey] = None,
    subnet_group: typing.Optional[_aws_cdk_aws_rds_ceddda9d.ISubnetGroup] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__69fb7eb5e4093f7582c9efcc795424d4ac254f144850a8d24b2f033cc9a46e8a(
    *,
    additional_behaviors: typing.Optional[typing.Mapping[builtins.str, typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.BehaviorOptions, typing.Dict[builtins.str, typing.Any]]]] = None,
    certificate: typing.Optional[_aws_cdk_aws_certificatemanager_ceddda9d.ICertificate] = None,
    comment: typing.Optional[builtins.str] = None,
    default_root_object: typing.Optional[builtins.str] = None,
    domain_names: typing.Optional[typing.Sequence[builtins.str]] = None,
    enabled: typing.Optional[builtins.bool] = None,
    enable_ipv6: typing.Optional[builtins.bool] = None,
    enable_logging: typing.Optional[builtins.bool] = None,
    error_responses: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_cloudfront_ceddda9d.ErrorResponse, typing.Dict[builtins.str, typing.Any]]]] = None,
    geo_restriction: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.GeoRestriction] = None,
    http_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.HttpVersion] = None,
    log_bucket: typing.Optional[_aws_cdk_aws_s3_ceddda9d.IBucket] = None,
    log_file_prefix: typing.Optional[builtins.str] = None,
    log_includes_cookies: typing.Optional[builtins.bool] = None,
    minimum_protocol_version: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SecurityPolicyProtocol] = None,
    price_class: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.PriceClass] = None,
    ssl_support_method: typing.Optional[_aws_cdk_aws_cloudfront_ceddda9d.SSLMethod] = None,
    web_acl_id: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__5835441daa450071f244ce1529963cf622560cbb994707bfd6ea0bafa8e8bc60(
    *,
    container_overrides: typing.Optional[typing.Union[_aws_cdk_aws_stepfunctions_tasks_ceddda9d.ContainerOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    service_overrides: typing.Optional[typing.Union[ServiceOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    task_definition_overrides: typing.Optional[typing.Union[TaskDefinitionOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__336da97d57a79070aa7f01c569cdd1ba666ad56b7ceab5361342aeaa58a2436d(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    site_id: builtins.str,
    static_hosting: StaticHosting,
    wordpress_admin_props: typing.Union[WordpressAdminProps, typing.Dict[builtins.str, typing.Any]],
    wordpress_docker_image: WordpressDockerImage,
    ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    wordpress_database_props: typing.Optional[typing.Union[WordpressDatabaseProps, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__950e0c1a49e60062031199dfbd8e50a498d62afb4aa28c650e5ad71bf60810fa(
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    site_id: builtins.str,
    static_hosting: StaticHosting,
    wordpress_admin_props: typing.Union[WordpressAdminProps, typing.Dict[builtins.str, typing.Any]],
    wordpress_docker_image: WordpressDockerImage,
    ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    wordpress_database_props: typing.Optional[typing.Union[WordpressDatabaseProps, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__027188d29eba3cd79c5f3dbba120e8792c24129976efd181c9c95fb3257c99a9(
    *,
    assign_public_ip: typing.Optional[builtins.bool] = None,
    capacity_provider_strategies: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CapacityProviderStrategy, typing.Dict[builtins.str, typing.Any]]]] = None,
    circuit_breaker: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentCircuitBreaker, typing.Dict[builtins.str, typing.Any]]] = None,
    cloud_map_options: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.CloudMapOptions, typing.Dict[builtins.str, typing.Any]]] = None,
    cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
    deployment_controller: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.DeploymentController, typing.Dict[builtins.str, typing.Any]]] = None,
    desired_count: typing.Optional[jsii.Number] = None,
    enable_ecs_managed_tags: typing.Optional[builtins.bool] = None,
    enable_execute_command: typing.Optional[builtins.bool] = None,
    health_check_grace_period: typing.Optional[_aws_cdk_ceddda9d.Duration] = None,
    max_healthy_percent: typing.Optional[jsii.Number] = None,
    min_healthy_percent: typing.Optional[jsii.Number] = None,
    platform_version: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.FargatePlatformVersion] = None,
    propagate_tags: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.PropagatedTagSource] = None,
    security_groups: typing.Optional[typing.Sequence[_aws_cdk_aws_ec2_ceddda9d.ISecurityGroup]] = None,
    service_connect_configuration: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.ServiceConnectProps, typing.Dict[builtins.str, typing.Any]]] = None,
    service_name: typing.Optional[builtins.str] = None,
    task_definition: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.TaskDefinition] = None,
    vpc_subnets: typing.Optional[typing.Union[_aws_cdk_aws_ec2_ceddda9d.SubnetSelection, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__fdb5af709ea71dc174f022c325998cdda1f85b7048c66e9964dc50f8891a64f5(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    site_id: builtins.str,
    cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    redirects: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__4e58a4a8525a11f65e814923cb6ab06fb9cb76df734dd725a10555e5ef0566d3(
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    site_id: builtins.str,
    cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    redirects: typing.Optional[typing.Mapping[builtins.str, builtins.str]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__dd2fc1160a4ad96c3edecf2c41ed215045efabbae073ac6c254b3d2b08bb33f3(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    wordpress_admin_props: typing.Union[WordpressAdminProps, typing.Dict[builtins.str, typing.Any]],
    cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
    site_id: typing.Optional[builtins.str] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    wordpress_database_props: typing.Optional[typing.Union[WordpressDatabaseProps, typing.Dict[builtins.str, typing.Any]]] = None,
    wordpress_docker_image_props: typing.Optional[typing.Union[WordpressDockerImageProps, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__c420ed92f5e98468a707cd8ba569ab19533c46331752a69967ed0b016fb29fab(
    *,
    fully_qualified_site_name: builtins.str,
    hosted_zone: _aws_cdk_aws_route53_ceddda9d.IHostedZone,
    wordpress_admin_props: typing.Union[WordpressAdminProps, typing.Dict[builtins.str, typing.Any]],
    cloud_front_distribution_config: typing.Optional[typing.Union[CloudFrontDistributionConfig, typing.Dict[builtins.str, typing.Any]]] = None,
    ecs_cluster: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ICluster] = None,
    site_id: typing.Optional[builtins.str] = None,
    vpc: typing.Optional[_aws_cdk_aws_ec2_ceddda9d.IVpc] = None,
    wordpress_database_props: typing.Optional[typing.Union[WordpressDatabaseProps, typing.Dict[builtins.str, typing.Any]]] = None,
    wordpress_docker_image_props: typing.Optional[typing.Union[WordpressDockerImageProps, typing.Dict[builtins.str, typing.Any]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__ef07f9fa7c26eb0238f2a69e33ab4d84cb09fccd5d145569a1fcfb7c413627e8(
    *,
    cpu: typing.Optional[jsii.Number] = None,
    ephemeral_storage_gib: typing.Optional[jsii.Number] = None,
    execution_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    family: typing.Optional[builtins.str] = None,
    memory_limit_mib: typing.Optional[jsii.Number] = None,
    proxy_configuration: typing.Optional[_aws_cdk_aws_ecs_ceddda9d.ProxyConfiguration] = None,
    runtime_platform: typing.Optional[typing.Union[_aws_cdk_aws_ecs_ceddda9d.RuntimePlatform, typing.Dict[builtins.str, typing.Any]]] = None,
    task_role: typing.Optional[_aws_cdk_aws_iam_ceddda9d.IRole] = None,
    volumes: typing.Optional[typing.Sequence[typing.Union[_aws_cdk_aws_ecs_ceddda9d.Volume, typing.Dict[builtins.str, typing.Any]]]] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__12958bbeb6a92f2fb3977ebb70c5fda7295edc247aaafd0b4d536120017faaae(
    *,
    email: builtins.str,
    domain_prefix: typing.Optional[builtins.str] = None,
    ecs_overrides: typing.Optional[typing.Union[EcsOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    password: typing.Optional[builtins.str] = None,
    run: typing.Optional[builtins.bool] = None,
    username: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__51ed18e24d8910c7a23c095d16dc64c07cb1c3864ee25e5115c97150899078a7(
    *,
    database_overrides: typing.Optional[typing.Union[DatabaseOverrides, typing.Dict[builtins.str, typing.Any]]] = None,
    password: typing.Optional[builtins.str] = None,
    username: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__aae0b4436edf3a96a8116dd877888ed1b78fcabcd44330904671d670c294e75f(
    scope: _constructs_77d1e7e8.Construct,
    id: builtins.str,
    *,
    container_cpu: typing.Optional[jsii.Number] = None,
    container_memory: typing.Optional[jsii.Number] = None,
    wordpress_docker_image_base: typing.Optional[builtins.str] = None,
    wordpress_memory_limit: typing.Optional[builtins.str] = None,
    wp2_static_s3_addon_version: typing.Optional[builtins.str] = None,
    wp2_static_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass

def _typecheckingstub__1189129bfa0fbc7a19851bb9e547d015c96ad47f3ec32df85a06a19b2a55189f(
    *,
    container_cpu: typing.Optional[jsii.Number] = None,
    container_memory: typing.Optional[jsii.Number] = None,
    wordpress_docker_image_base: typing.Optional[builtins.str] = None,
    wordpress_memory_limit: typing.Optional[builtins.str] = None,
    wp2_static_s3_addon_version: typing.Optional[builtins.str] = None,
    wp2_static_version: typing.Optional[builtins.str] = None,
) -> None:
    """Type checking stubs"""
    pass
