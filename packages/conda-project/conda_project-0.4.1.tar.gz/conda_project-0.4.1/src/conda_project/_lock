
        # local_dependencies = {}
        # for dep in p.depends:
        #     matchspec = MatchSpec(dep)
        #     name = matchspec.name
        #     version = (
        #         matchspec.version.spec_str if matchspec.version is not None else ""
        #     )
        #     local_dependencies[name] = version

        # if p.schannel == "pypi":
        #     if "WHEEL" in str(p.package_type):
        #         for fn in p.files:
        #             fn = prefix / Path(fn)
        #             if fn.name == "WHEEL":
        #                 with fn.open() as f:
        #                     data = f.readlines()
        #                 lines = [line for line in data if line.startswith("Tag")]
        #                 if lines:
        #                     tag = lines[0].split(":", maxsplit=1)[1].strip()
        #                     wheel = f"{p.name}-{p.version}-{tag}.whl"
        #                     parsed = parse_wheel_filename(wheel)
        #                     url = f"https://files.pythonhosted.org/packages/{parsed.python_tags[0]}/"
        #                           f"{parsed.project[0]}/{parsed.project}/{p.name}-{p.version}-{tag}.whl"
        #                 break
        #     else:
        #         url = f"https://pypi.io/packages/source/{p.name[0]}/{p.name}/{p.name}-{p.version}.tar.gz"
        # else:
        #     url = str(p.url)

        # locked.append(LockedDependency(
        #     name=p.name,
        #     version=p.version,
        #     manager="pip" if p.schannel == "pypi" else "conda",
        #     platform="unknown",
        #     dependencies=local_dependencies,
        #     url=url,
        #     hash=HashModel(
        #         md5=p.get("md5"),
        #         sha256=p.get("sha256")
        #     ),
        # ))
    # lock_content = Lockfile(
    #     package=locked,
    #     metadata=LockMeta(
    #         content_hash=spec.content_hash(),
    #         channels=list(),
    #         platforms=[current_platform()],
    #         sources=["environment.yml"],
    #     ),
    # )


# def requested_packages(prefix: Path, with_version: bool = True) -> EnvironmentYaml:
#     proc = call_conda(["env", "export", "--from-history", "-p", str(prefix), "--json"])
#     requested = json.loads(proc.stdout)

#     proc = call_conda(["env", "export", "-p", str(prefix), "--json"])
#     full = json.loads(proc.stdout)

#     if with_version:
#         versioned_dependencies = []

#         dependencies = {}
#         for d in requested["dependencies"]:
#             split = d.split("::", maxsplit=1)
#             if len(split) == 1:
#                 name = split[0].split("=")[0]
#                 dependencies[name] = ""
#             else:
#                 channel, name = split
#                 dependencies[name.split("=")[0]] = f"{channel}::"

#         for d in full["dependencies"]:
#             if isinstance(d, str):
#                 name, version, _ = d.split("=")
#                 if name in dependencies:
#                     prefix = dependencies[name]
#                     versioned_dependencies.append(f"{prefix}{name}={version}")

#         requested["dependencies"] = versioned_dependencies

#     pip_pkgs = [p for p in full["dependencies"] if isinstance(p, dict) and "pip" in p]
#     if pip_pkgs:
#         pip_pkgs = [p for p in pip_pkgs[0]["pip"] if not p.startswith("anaconda")]
#         requested["dependencies"].append({"pip": pip_pkgs})

#     environment = EnvironmentYaml(**requested)
#     return environment