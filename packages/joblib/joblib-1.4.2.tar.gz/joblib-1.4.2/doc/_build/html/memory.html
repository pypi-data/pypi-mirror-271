
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>On demand recomputing: the Memory class &#8212; joblib 1.3.2 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-binder.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-dataframe.css" />
    <link rel="stylesheet" type="text/css" href="_static/sg_gallery-rendered-html.css" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <link rel="shortcut icon" href="_static/favicon.ico"/>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Embarrassingly parallel for loops" href="parallel.html" />
    <link rel="prev" title="Installing joblib" href="installing.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="on-demand-recomputing-the-memory-class">
<span id="memory"></span><h1>On demand recomputing: the <cite>Memory</cite> class<a class="headerlink" href="#on-demand-recomputing-the-memory-class" title="Permalink to this headline">¶</a></h1>
<section id="use-case">
<h2>Use case<a class="headerlink" href="#use-case" title="Permalink to this headline">¶</a></h2>
<p>The <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory" title="joblib.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a> class defines a context for lazy evaluation of
function, by putting the results in a store, by default using a disk, and not
re-running the function twice for the same arguments.</p>
<p>It works by explicitly saving the output to a file and it is designed to
work with non-hashable and potentially large input and output data types
such as numpy arrays.</p>
<section id="a-simple-example">
<h3>A simple example:<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>First, define the cache directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cachedir</span> <span class="o">=</span> <span class="s1">&#39;your_cache_location_directory&#39;</span>
</pre></div>
</div>
<p>Then, instantiate a memory context that uses this cache directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">Memory</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">cachedir</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>After these initial steps, just decorate a function to cache its output in
this context:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running f(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span>
</pre></div>
</div>
<p>Calling this function twice with the same argument does not execute it the
second time, the output is just reloaded from a pickle file in the cache
directory:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">Running f(1)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="go">1</span>
</pre></div>
</div>
<p>However, calling the function with a different parameter executes it and
recomputes the output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="go">Running f(2)</span>
<span class="go">2</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="comparison-with-memoize">
<h3>Comparison with <cite>memoize</cite><a class="headerlink" href="#comparison-with-memoize" title="Permalink to this headline">¶</a></h3>
<p>The <cite>memoize</cite> decorator (<a class="reference external" href="https://code.activestate.com/recipes/52201/">https://code.activestate.com/recipes/52201/</a>)
caches in memory all the inputs and outputs of a function call. It can
thus avoid running twice the same function, with a very small
overhead. However, it compares input objects with those in cache on each
call. As a result, for big objects there is a huge overhead. Moreover
this approach does not work with numpy arrays, or other objects subject
to non-significant fluctuations. Finally, using <cite>memoize</cite> with large
objects will consume all the memory, where with <cite>Memory</cite>, objects are
persisted to disk, using a persister optimized for speed and memory
usage (<a class="reference internal" href="generated/joblib.dump.html#joblib.dump" title="joblib.dump"><code class="xref py py-func docutils literal notranslate"><span class="pre">joblib.dump()</span></code></a>).</p>
<p>In short, <cite>memoize</cite> is best suited for functions with “small” input and
output objects, whereas <cite>Memory</cite> is best suited for functions with complex
input and output objects, and aggressive persistence to disk.</p>
</section>
</section>
<section id="using-with-numpy">
<h2>Using with <cite>numpy</cite><a class="headerlink" href="#using-with-numpy" title="Permalink to this headline">¶</a></h2>
<p>The original motivation behind the <cite>Memory</cite> context was to have a
memoize-like pattern on numpy arrays. <cite>Memory</cite> uses fast cryptographic
hashing of the input arguments to check if they have been computed.</p>
<section id="an-example">
<h3>An example<a class="headerlink" href="#an-example" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>Define two functions: the first with a number as an argument,
outputting an array, used by the second one. Both functions are decorated
with <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory.cache" title="joblib.Memory.cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Memory.cache</span></code></a>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A long-running calculation, with parameter </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">hamming</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">h</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;A second long-running calculation, using g(x)&#39;</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>If the function <cite>h</cite> is called with the array created by the same call to <cite>g</cite>,
<cite>h</cite> is not re-run:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">A long-running calculation, with parameter 3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span>
<span class="go">array([0.08, 1.  , 0.08])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">array([0.08, 1.  , 0.08])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">A second long-running calculation, using g(x)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span> <span class="o">=</span> <span class="n">h</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">b2</span>
<span class="go">array([[0.0064, 0.08  , 1.    ],</span>
<span class="go">       [1.    , 1.    , 1.    ],</span>
<span class="go">       [0.0064, 0.08  , 1.    ]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</div></blockquote>
</section>
<section id="using-memmapping">
<h3>Using memmapping<a class="headerlink" href="#using-memmapping" title="Permalink to this headline">¶</a></h3>
<p>Memmapping (memory mapping) speeds up cache looking when reloading large numpy
arrays:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cachedir2</span> <span class="o">=</span> <span class="s1">&#39;your_cachedir2_location&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">memory2</span> <span class="o">=</span> <span class="n">Memory</span><span class="p">(</span><span class="n">cachedir2</span><span class="p">,</span> <span class="n">mmap_mode</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">memory2</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vander</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="go">________________________________________________________________________________</span>
<span class="go">[Memory] Calling square...</span>
<span class="go">square(array([[0., 0., 1.],</span>
<span class="go">       [1., 1., 1.],</span>
<span class="go">       [4., 2., 1.]]))</span>
<span class="go">___________________________________________________________square - ...min</span>
<span class="go">memmap([[ 0.,  0.,  1.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [16.,  4.,  1.]])</span>
</pre></div>
</div>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Notice the debug mode used in the above example. It is useful for
tracing of what is being reexecuted, and where the time is spent.</p>
</div>
<p>If the <cite>square</cite> function is called with the same input argument, its
return value is loaded from the disk using memmapping:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">res</span> <span class="o">=</span> <span class="n">square</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">repr</span><span class="p">(</span><span class="n">res</span><span class="p">))</span>
<span class="go">memmap([[ 0.,  0.,  1.],</span>
<span class="go">        [ 1.,  1.,  1.],</span>
<span class="go">        [16.,  4.,  1.]])</span>
</pre></div>
</div>
<blockquote>
<div><p>The memmap file must be closed to avoid file locking on Windows; closing
numpy.memmap objects is done with del, which flushes changes to the disk</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">del</span> <span class="n">res</span>
</pre></div>
</div>
</div></blockquote>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the memory mapping mode used was ‘r’, as in the above example, the
array will be read only, and will be impossible to modified in place.</p>
<p>On the other hand, using ‘r+’ or ‘w+’ will enable modification of the
array, but will propagate these modification to the disk, which will
corrupt the cache. If you want modification of the array in memory, we
suggest you use the ‘c’ mode: copy on write.</p>
</div>
</section>
</section>
<section id="shelving-using-references-to-cached-values">
<h2>Shelving: using references to cached values<a class="headerlink" href="#shelving-using-references-to-cached-values" title="Permalink to this headline">¶</a></h2>
<p>In some cases, it can be useful to get a reference to the cached
result, instead of having the result itself. A typical example of this
is when a lot of large numpy arrays must be dispatched across several
workers: instead of sending the data themselves over the network, send
a reference to the joblib cache, and let the workers read the data
from a network filesystem, potentially taking advantage of some
system-level caching too.</p>
<p>Getting a reference to the cache can be done using the
<cite>call_and_shelve</cite> method on the wrapped function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">call_and_shelve</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
<span class="go">A long-running calculation, with parameter 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span>  
<span class="go">MemorizedResult(location=&quot;...&quot;, func=&quot;...g...&quot;, args_id=&quot;...&quot;)</span>
</pre></div>
</div>
<p>Once computed, the output of <cite>g</cite> is stored on disk, and deleted from
memory. Reading the associated value can then be performed with the
<cite>get</cite> method:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>
<span class="go">array([0.08, 0.77, 0.77, 0.08])</span>
</pre></div>
</div>
<p>The cache for this particular value can be cleared using the <cite>clear</cite>
method. Its invocation causes the stored value to be erased from disk.
Any subsequent call to <cite>get</cite> will cause a <cite>KeyError</cite> exception to be
raised:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span><span class="o">.</span><span class="n">get</span><span class="p">()</span>  
<span class="gt">Traceback (most recent call last):</span>
<span class="c">...</span>
<span class="gr">KeyError</span>: <span class="n">&#39;Non-existing cache value (may have been cleared).\nFile ... does not exist&#39;</span>
</pre></div>
</div>
<p>A <cite>MemorizedResult</cite> instance contains all that is necessary to read
the cached value. It can be pickled for transmission or storage, and
the printed representation can even be copy-pasted to a different
python interpreter.</p>
<div class="topic">
<p class="topic-title">Shelving when cache is disabled</p>
<p>In the case where caching is disabled (e.g.
<cite>Memory(None)</cite>), the <cite>call_and_shelve</cite> method returns a
<cite>NotMemorizedResult</cite> instance, that stores the full function
output, instead of just a reference (since there is nothing to
point to). All the above remains valid though, except for the
copy-pasting feature.</p>
</div>
</section>
<section id="gotchas">
<h2>Gotchas<a class="headerlink" href="#gotchas" title="Permalink to this headline">¶</a></h2>
<ul>
<li><p><strong>Across sessions, function cache is identified by the function’s name</strong>.
Thus assigning the same name to different functions, their cache will
override each-others (e.g. there are ‘name collisions’), and unwanted re-run
will happen:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running func(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span> <span class="o">=</span> <span class="n">func</span>

<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running a different func(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>As long as the same session is used, there are no collisions (in joblib
0.8 and above), although joblib does warn you that you are doing something
dangerous:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Running a different func(1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="c1"># FIXME: The next line should create a JolibCollisionWarning but does not</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># memory.rst:0: JobLibCollisionWarning: Possible name collisions between functions &#39;func&#39; (&lt;doctest memory.rst&gt;:...) and &#39;func&#39; (&lt;doctest memory.rst&gt;:...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">Running func(1)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># No recomputation so far</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># No recomputation so far</span>
</pre></div>
</div>
<p>But suppose the interpreter is exited and then restarted, the cache will not
be identified properly, and the functions will be rerun:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># FIXME: The next line will should create a JoblibCollisionWarning but does not. Also it is skipped because it does not produce any output</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># memory.rst:0: JobLibCollisionWarning: Possible name collisions between functions &#39;func&#39; (&lt;doctest memory.rst&gt;:...) and &#39;func&#39; (&lt;doctest memory.rst&gt;:...)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> 
<span class="go">Running a different func(1)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  
<span class="go">Running func(1)</span>
</pre></div>
</div>
<p>As long as the same session is used, there are no needless
recomputation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># No recomputation now</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func2</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># No recomputation now</span>
</pre></div>
</div>
</li>
<li><p><strong>lambda functions</strong></p>
<p>Beware that with Python 2.7 lambda functions cannot be separated out:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">my_print</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">my_print</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="k">lambda</span> <span class="p">:</span> <span class="n">my_print</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>

<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">()</span> 
<span class="go">memory.rst:0: JobLibCollisionWarning: Cannot detect name collisions for function &#39;&lt;lambda&gt;&#39;</span>
<span class="go">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="p">()</span> 
<span class="gp">&gt;&gt;&gt; </span><span class="n">f</span><span class="p">()</span> 
<span class="go">1</span>
</pre></div>
</div>
</li>
<li><p><strong>memory cannot be used on some complex objects</strong>, e.g. a callable
object with a <cite>__call__</cite> method.</p>
<p>However, it works on numpy ufuncs:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sin</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="go">0.0</span>
</pre></div>
</div>
</li>
<li><p><strong>caching methods: memory is designed for pure functions and it is
not recommended to use it for methods</strong>. If one wants to use cache
inside a class the recommended pattern is to cache a pure function
and use the cached function inside your class, i.e. something like
this:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="k">def</span> <span class="nf">compute_func</span><span class="p">(</span><span class="n">arg1</span><span class="p">,</span> <span class="n">arg2</span><span class="p">,</span> <span class="n">arg3</span><span class="p">):</span>
    <span class="c1"># long computation</span>
    <span class="k">return</span> <span class="n">result</span>


<span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">compute_func</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">arg1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">arg2</span><span class="p">,</span> <span class="mi">40</span><span class="p">)</span>
</pre></div>
</div>
<p>Using <code class="docutils literal notranslate"><span class="pre">Memory</span></code> for methods is not recommended and has some caveats
that make it very fragile from a maintenance point of view because
it is very easy to forget about these caveats when a software
evolves. If this cannot be avoided (we would be interested about
your use case by the way), here are a few known caveats:</p>
<ol class="arabic">
<li><p>a method cannot be decorated at class definition,
because when the class is instantiated, the first argument (self) is
<em>bound</em>, and no longer accessible to the <cite>Memory</cite> object. The
following code won’t work:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>  <span class="c1"># WRONG</span>
    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
<p>The right way to do this is to decorate at instantiation time:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">method</span> <span class="o">=</span> <span class="n">memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">method</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">method</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="k">pass</span>
</pre></div>
</div>
</li>
<li><p>The cached method will have <code class="docutils literal notranslate"><span class="pre">self</span></code> as one of its
arguments. That means that the result will be recomputed if
anything with <code class="docutils literal notranslate"><span class="pre">self</span></code> changes. For example if <code class="docutils literal notranslate"><span class="pre">self.attr</span></code> has
changed calling <code class="docutils literal notranslate"><span class="pre">self.method</span></code> will recompute the result even if
<code class="docutils literal notranslate"><span class="pre">self.method</span></code> does not use <code class="docutils literal notranslate"><span class="pre">self.attr</span></code> in its body. Another
example is changing <code class="docutils literal notranslate"><span class="pre">self</span></code> inside the body of
<code class="docutils literal notranslate"><span class="pre">self.method</span></code>. The consequence is that <code class="docutils literal notranslate"><span class="pre">self.method</span></code> will
create cache that will not be reused in subsequent calls. To
alleviate these problems and if you <em>know</em> that the result of
<code class="docutils literal notranslate"><span class="pre">self.method</span></code> does not depend on <code class="docutils literal notranslate"><span class="pre">self</span></code> you can use
<code class="docutils literal notranslate"><span class="pre">self.method</span> <span class="pre">=</span> <span class="pre">memory.cache(self.method,</span> <span class="pre">ignore=['self'])</span></code>.</p></li>
</ol>
</li>
<li><p><strong>joblib cache entries may be invalidated after environment updates</strong>.
Values returned by <a class="reference internal" href="generated/joblib.hash.html#joblib.hash" title="joblib.hash"><code class="xref py py-func docutils literal notranslate"><span class="pre">joblib.hash()</span></code></a> are not guaranteed to stay
constant across <code class="docutils literal notranslate"><span class="pre">joblib</span></code> versions. This means that <strong>all</strong> entries of a
<a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory" title="joblib.memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a> cache can get invalidated when upgrading <code class="docutils literal notranslate"><span class="pre">joblib</span></code>.
Invalidation can also happen when upgrading a third party library (such as
<code class="docutils literal notranslate"><span class="pre">numpy</span></code>): in such a case, only the cached function calls with parameters
that are constructs (or contain references to constructs) defined in the
upgraded library should potentially be invalidated after the upgrade.</p></li>
<li><p><strong>Cache-miss with objects that have non-reproducible pickle representations</strong>.
The identifier of the cache entry is based on the pickle’s representation of
the input arguments. Therefor, for objects that don’t have a deterministic
pickle representation, or objects whose representation depends on the way they
are constructed, the cache will not work. In particular, <code class="docutils literal notranslate"><span class="pre">pytorch.Tensor</span></code>
are known to have non-deterministic pickle representation (see this
<a class="reference external" href="https://github.com/pytorch/pytorch/issues/32165">issue</a>). A good way
to debug this is to check that two calls to the following script with <code class="docutils literal notranslate"><span class="pre">args</span></code>
and <code class="docutils literal notranslate"><span class="pre">kwargs</span></code> being the cached function’s inputs give the same output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="nb">hash</span>

<span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
  <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;hash(</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">)=</span><span class="si">{</span><span class="nb">hash</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>To avoid this issue, a good practice for reliable caching is to mostly use
<code class="docutils literal notranslate"><span class="pre">Memory.cache</span></code> with functions that take simple input arguments if possible.</p>
</li>
</ul>
</section>
<section id="ignoring-some-arguments">
<h2>Ignoring some arguments<a class="headerlink" href="#ignoring-some-arguments" title="Permalink to this headline">¶</a></h2>
<p>It may be useful not to recalculate a function when certain arguments
change, for instance a debug flag. <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory" title="joblib.memory.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a> provides the <code class="docutils literal notranslate"><span class="pre">ignore</span></code>
list:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">ignore</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">])</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Called with x = </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="go">Called with x = 0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># my_func was not reevaluated</span>
</pre></div>
</div>
</section>
<section id="custom-cache-validation">
<h2>Custom cache validation<a class="headerlink" href="#custom-cache-validation" title="Permalink to this headline">¶</a></h2>
<p>In some cases, external factors can invalidate the cached results and
one wants to have more control on whether to reuse a result or not.</p>
<p>This is for instance the case if the results depends on database records
that change over time: a small delay in the updates might be tolerable
but after a while, the results might be invalid.</p>
<p>One can have a finer control on the cache validity specifying a function
via <code class="docutils literal notranslate"><span class="pre">cache_validation_callback</span></code> in <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory.cache" title="joblib.Memory.cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">cache()</span></code></a>. For
instance, one can only cache results that take more than 1s to be computed.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">time</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">def</span> <span class="nf">cache_validation_cb</span><span class="p">(</span><span class="n">metadata</span><span class="p">):</span>
<span class="gp">... </span>    <span class="c1"># Only retrieve cached results for calls that take more than 1s</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">metadata</span><span class="p">[</span><span class="s1">&#39;duration&#39;</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">cache_validation_callback</span><span class="o">=</span><span class="n">cache_validation_cb</span><span class="p">)</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">(</span><span class="n">delay</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">delay</span><span class="p">)</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Called with </span><span class="si">{</span><span class="n">delay</span><span class="si">}</span><span class="s1">s delay&#39;</span><span class="p">)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">()</span>
<span class="go">Called with 0s delay</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>
<span class="go">Called with 1.1s delay</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>  <span class="c1"># This result is retrieved from cache</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">()</span>  <span class="c1"># This one is not and the call is repeated</span>
<span class="go">Called with 0s delay</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">cache_validation_cb</span></code> will be called with a single argument containing
the metadata of the cached call as a dictionary containing the following
keys:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">duration</span></code>: the duration of the function call,</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">time</span></code>: the timestamp when the cache called has been recorded</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">input_args</span></code>: a dictionary of keywords arguments for the cached function call.</p></li>
</ul>
</div></blockquote>
<p>Note a validity duration for cached results can be defined via
<a class="reference internal" href="#joblib.expires_after" title="joblib.expires_after"><code class="xref py py-func docutils literal notranslate"><span class="pre">joblib.expires_after()</span></code></a> by providing similar with arguments similar to the
ones of a <code class="docutils literal notranslate"><span class="pre">datetime.timedelta</span></code>:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">joblib</span> <span class="kn">import</span> <span class="n">expires_after</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span><span class="p">(</span><span class="n">cache_validation_callback</span><span class="o">=</span><span class="n">expires_after</span><span class="p">(</span><span class="n">seconds</span><span class="o">=</span><span class="mf">0.5</span><span class="p">))</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">my_func</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Function run&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">()</span>
<span class="go">Function run</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">my_func</span><span class="p">()</span>
<span class="go">Function run</span>
</pre></div>
</div>
</section>
<section id="reference-documentation-of-the-memory-class">
<span id="memory-reference"></span><h2>Reference documentation of the <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory" title="joblib.Memory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code></a> class<a class="headerlink" href="#reference-documentation-of-the-memory-class" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joblib.</span></span><span class="sig-name descname"><span class="pre">Memory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">location</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bytes_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>A context object for caching a function’s return value each time it
is called with the same input arguments.</p>
<p>All values are cached on the filesystem, in a deep directory
structure.</p>
<p>Read more in the <a class="reference internal" href="#memory"><span class="std std-ref">User Guide</span></a>.</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>location: str, pathlib.Path or None</strong></dt><dd><p>The path of the base directory to use as a data store
or None. If None is given, no caching is done and
the Memory object is completely transparent. This option
replaces cachedir since version 0.12.</p>
</dd>
<dt><strong>backend: str, optional</strong></dt><dd><p>Type of store backend for reading/writing cache files.
Default: ‘local’.
The ‘local’ backend is using regular filesystem operations to
manipulate data (open, mv, etc) in the backend.</p>
</dd>
<dt><strong>mmap_mode: {None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional</strong></dt><dd><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments.</p>
</dd>
<dt><strong>compress: boolean, or integer, optional</strong></dt><dd><p>Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.</p>
</dd>
<dt><strong>verbose: int, optional</strong></dt><dd><p>Verbosity flag, controls the debug messages that are issued
as functions are evaluated.</p>
</dd>
<dt><strong>bytes_limit: int | str, optional</strong></dt><dd><p>Limit in bytes of the size of the cache. By default, the size of
the cache is unlimited. When reducing the size of the cache,
<code class="docutils literal notranslate"><span class="pre">joblib</span></code> keeps the most recently accessed items first. If a
str is passed, it is converted to a number of bytes using units
{ K | M | G} for kilo, mega, giga.</p>
<p><strong>Note:</strong> You need to call <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory.reduce_size" title="joblib.Memory.reduce_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">joblib.Memory.reduce_size()</span></code></a> to
actually reduce the cache size to be less than <code class="docutils literal notranslate"><span class="pre">bytes_limit</span></code>.</p>
<p><strong>Note:</strong> This argument has been deprecated. One should give the
value of <code class="docutils literal notranslate"><span class="pre">bytes_limit</span></code> directly in
<a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory.reduce_size" title="joblib.Memory.reduce_size"><code class="xref py py-meth docutils literal notranslate"><span class="pre">joblib.Memory.reduce_size()</span></code></a>.</p>
</dd>
<dt><strong>backend_options: dict, optional</strong></dt><dd><p>Contains a dictionary of named parameters used to configure
the store backend.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">location</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bytes_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend_options</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth: int, optional</strong></dt><dd><p>The depth of objects printed.</p>
</dd>
<dt><strong>name: str, optional</strong></dt><dd><p>The namespace to log to. If None, defaults to joblib.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_validation_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Decorates the given function func to only compute its return
value for input arguments not cached on disk.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: callable, optional</strong></dt><dd><p>The function to be decorated</p>
</dd>
<dt><strong>ignore: list of strings</strong></dt><dd><p>A list of arguments name to ignore in the hashing</p>
</dd>
<dt><strong>verbose: integer, optional</strong></dt><dd><p>The verbosity mode of the function. By default that
of the memory object is used.</p>
</dd>
<dt><strong>mmap_mode: {None, ‘r+’, ‘r’, ‘w+’, ‘c’}, optional</strong></dt><dd><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the
arguments. By default that of the memory object is used.</p>
</dd>
<dt><strong>cache_validation_callback: callable, optional</strong></dt><dd><p>Callable to validate whether or not the cache is valid. When
the cached function is called with arguments for which a cache
exists, this callable is called with the metadata of the cached
result as its sole argument. If it returns True, then the
cached result is returned, else the cache for these arguments
is cleared and recomputed.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt>decorated_func: MemorizedFunc object</dt><dd><p>The returned object is a MemorizedFunc object, that is
callable (behaves like a function), but offers extra
methods for cache lookup and management. See the
documentation for <a class="reference internal" href="#joblib.memory.MemorizedFunc" title="joblib.memory.MemorizedFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">joblib.memory.MemorizedFunc</span></code></a>.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Erase the complete cache directory.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Eval function func with arguments <cite>*args</cite> and <cite>**kwargs</cite>,
in the context of the memory.</p>
<p>This method works similarly to the builtin <cite>apply</cite>, except
that the function is called only if the cache is not
up to date.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">format</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">obj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indent</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Return the formatted representation of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py">
<span class="sig-name descname"><span class="pre">reduce_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bytes_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">items_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">age_limit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span></dt>
<dd><p>Remove cache elements to make the cache fit its limits.</p>
<p>The limitation can impose that the cache size fits in <code class="docutils literal notranslate"><span class="pre">bytes_limit</span></code>,
that the number of cache items is no more than <code class="docutils literal notranslate"><span class="pre">items_limit</span></code>, and
that all files in cache are not older than <code class="docutils literal notranslate"><span class="pre">age_limit</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>bytes_limit: int | str, optional</strong></dt><dd><p>Limit in bytes of the size of the cache. By default, the size of
the cache is unlimited. When reducing the size of the cache,
<code class="docutils literal notranslate"><span class="pre">joblib</span></code> keeps the most recently accessed items first. If a
str is passed, it is converted to a number of bytes using units
{ K | M | G} for kilo, mega, giga.</p>
</dd>
<dt><strong>items_limit: int, optional</strong></dt><dd><p>Number of items to limit the cache to.  By default, the number of
items in the cache is unlimited.  When reducing the size of the
cache, <code class="docutils literal notranslate"><span class="pre">joblib</span></code> keeps the most recently accessed items first.</p>
</dd>
<dt><strong>age_limit: datetime.timedelta, optional</strong></dt><dd><p>Maximum age of items to limit the cache to.  When reducing the size
of the cache, any items last accessed more than the given length of
time ago are deleted.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="useful-methods-of-decorated-functions">
<h2>Useful methods of decorated functions<a class="headerlink" href="#useful-methods-of-decorated-functions" title="Permalink to this headline">¶</a></h2>
<p>Functions decorated by <a class="reference internal" href="generated/joblib.Memory.html#joblib.Memory.cache" title="joblib.Memory.cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">Memory.cache</span></code></a> are
<a class="reference internal" href="#joblib.memory.MemorizedFunc" title="joblib.memory.MemorizedFunc"><code class="xref py py-class docutils literal notranslate"><span class="pre">MemorizedFunc</span></code></a>
objects that, in addition of behaving like normal functions, expose
methods useful for cache exploration and management. For example, you can
use <a class="reference internal" href="#joblib.memory.MemorizedFunc.check_call_in_cache" title="joblib.memory.MemorizedFunc.check_call_in_cache"><code class="xref py py-meth docutils literal notranslate"><span class="pre">func.check_call_in_cache</span></code></a> to
check if a cache hit will occur for a decorated <code class="docutils literal notranslate"><span class="pre">func</span></code> given a set of inputs
without actually needing to call the function itself:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nd">@memory</span><span class="o">.</span><span class="n">cache</span>
<span class="gp">... </span><span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="gp">... </span>    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Running func(</span><span class="si">%s</span><span class="s1">)&#39;</span> <span class="o">%</span> <span class="n">x</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">return</span> <span class="n">x</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
<span class="go">&lt;class &#39;joblib.memory.MemorizedFunc&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">Running func(1)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">check_call_in_cache</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># cache hit</span>
<span class="go">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">func</span><span class="o">.</span><span class="n">check_call_in_cache</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>  <span class="c1"># cache miss</span>
<span class="go">False</span>
</pre></div>
</div>
<dl class="py class">
<dt class="sig sig-object py" id="joblib.memory.MemorizedFunc">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">joblib.memory.</span></span><span class="sig-name descname"><span class="pre">MemorizedFunc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_validation_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.memory.MemorizedFunc" title="Permalink to this definition">¶</a></dt>
<dd><p>Callable object decorating a function for caching its return value
each time it is called.</p>
<p>Methods are provided to inspect the cache or clean it.</p>
<dl class="field-list simple">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>func: callable</strong></dt><dd><p>The original, undecorated, function.</p>
</dd>
<dt><strong>location: string</strong></dt><dd><p>The location of joblib cache. Depends on the store backend used.</p>
</dd>
<dt><strong>backend: str</strong></dt><dd><p>Type of store backend for reading/writing cache files.
Default is ‘local’, in which case the location is the path to a
disk storage.</p>
</dd>
<dt><strong>ignore: list or None</strong></dt><dd><p>List of variable names to ignore when choosing whether to
recompute.</p>
</dd>
<dt><strong>mmap_mode: {None, ‘r+’, ‘r’, ‘w+’, ‘c’}</strong></dt><dd><p>The memmapping mode used when loading from cache
numpy arrays. See numpy.load for the meaning of the different
values.</p>
</dd>
<dt><strong>compress: boolean, or integer</strong></dt><dd><p>Whether to zip the stored data on disk. If an integer is
given, it should be between 1 and 9, and sets the amount
of compression. Note that compressed arrays cannot be
read by memmapping.</p>
</dd>
<dt><strong>verbose: int, optional</strong></dt><dd><p>The verbosity flag, controls messages that are issued as
the function is evaluated.</p>
</dd>
<dt><strong>cache_validation_callback: callable, optional</strong></dt><dd><p>Callable to check if a result in cache is valid or is to be recomputed.
When the function is called with arguments for which a cache exists,
the callback is called with the cache entry’s metadata as its sole
argument. If it returns True, the cached result is returned, else the
cache for these arguments is cleared and the result is recomputed.</p>
</dd>
</dl>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="joblib.memory.MemorizedFunc.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">location</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'local'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ignore</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mmap_mode</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compress</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cache_validation_callback</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.memory.MemorizedFunc.__init__" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>depth: int, optional</strong></dt><dd><p>The depth of objects printed.</p>
</dd>
<dt><strong>name: str, optional</strong></dt><dd><p>The namespace to log to. If None, defaults to joblib.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joblib.memory.MemorizedFunc.call">
<span class="sig-name descname"><span class="pre">call</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.memory.MemorizedFunc.call" title="Permalink to this definition">¶</a></dt>
<dd><p>Force the execution of the function with the given arguments.</p>
<p>The output values will be persisted, i.e., the cache will be updated
with any new values.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>*args: arguments</strong></dt><dd><p>The arguments.</p>
</dd>
<dt><strong>**kwargs: keyword arguments</strong></dt><dd><p>Keyword arguments.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>output</strong><span class="classifier">object</span></dt><dd><p>The output of the function call.</p>
</dd>
<dt><strong>metadata</strong><span class="classifier">dict</span></dt><dd><p>The metadata associated with the call.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joblib.memory.MemorizedFunc.check_call_in_cache">
<span class="sig-name descname"><span class="pre">check_call_in_cache</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.memory.MemorizedFunc.check_call_in_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Check if function call is in the memory cache.</p>
<p>Does not call the function or do any work besides func inspection
and arg hashing.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><dl class="simple">
<dt>is_call_in_cache: bool</dt><dd><p>Whether or not the result of the function has been cached
for the input arguments that have been passed.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="joblib.memory.MemorizedFunc.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">warn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.memory.MemorizedFunc.clear" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty the function’s cache.</p>
</dd></dl>

</dd></dl>

<section id="helper-reference">
<h3>Helper Reference<a class="headerlink" href="#helper-reference" title="Permalink to this headline">¶</a></h3>
<dl class="py function">
<dt class="sig sig-object py" id="joblib.expires_after">
<span class="sig-prename descclassname"><span class="pre">joblib.</span></span><span class="sig-name descname"><span class="pre">expires_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">days</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seconds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">microseconds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">milliseconds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minutes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hours</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weeks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#joblib.expires_after" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper cache_validation_callback to force recompute after a duration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>days, seconds, microseconds, milliseconds, minutes, hours, weeks: numbers</strong></dt><dd><p>argument passed to a timedelta.</p>
</dd>
</dl>
</dd>
</dl>
</dd></dl>

</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="index.html">
    <img class="logo" src="_static/joblib_logo.svg" alt="Logo"/>
    
  </a>
</p>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">User manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="why.html">Why joblib: project goals</a></li>
<li class="toctree-l1"><a class="reference internal" href="installing.html">Installing joblib</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">On demand recomputing: the <cite>Memory</cite> class</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#use-case">Use case</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-with-numpy">Using with <cite>numpy</cite></a></li>
<li class="toctree-l2"><a class="reference internal" href="#shelving-using-references-to-cached-values">Shelving: using references to cached values</a></li>
<li class="toctree-l2"><a class="reference internal" href="#gotchas">Gotchas</a></li>
<li class="toctree-l2"><a class="reference internal" href="#ignoring-some-arguments">Ignoring some arguments</a></li>
<li class="toctree-l2"><a class="reference internal" href="#custom-cache-validation">Custom cache validation</a></li>
<li class="toctree-l2"><a class="reference internal" href="#reference-documentation-of-the-memory-class">Reference documentation of the <code class="xref py py-class docutils literal notranslate"><span class="pre">Memory</span></code> class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#useful-methods-of-decorated-functions">Useful methods of decorated functions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="parallel.html">Embarrassingly parallel for loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="persistence.html">Persistence</a></li>
<li class="toctree-l1"><a class="reference internal" href="auto_examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="developing.html">Development</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Module reference</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.Memory.html">joblib.Memory</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.Parallel.html">joblib.Parallel</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.parallel_config.html">joblib.parallel_config</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.dump.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code>.dump</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.load.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code>.load</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.hash.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code>.hash</a></li>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.register_compressor.html"><code class="xref py py-mod docutils literal notranslate"><span class="pre">joblib</span></code>.register_compressor</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Deprecated functionalities</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="generated/joblib.parallel_backend.html">joblib.parallel_backend</a></li>
</ul>


        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2008-2021, Joblib developers.
      
      |
      <a href="_sources/memory.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>