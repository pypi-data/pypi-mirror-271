/*===- TableGen'erated file -------------------------------------*- C++ -*-===*\
|*                                                                            *|
|* Op Declarations                                                            *|
|*                                                                            *|
|* Automatically generated file, do not edit!                                 *|
|* From: xla_cpu_ops.td                                                       *|
|*                                                                            *|
\*===----------------------------------------------------------------------===*/

namespace mlir {
namespace xla_cpu {
class AddDependencyOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class AllReduceOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class AllToAllOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class CollectivePermuteOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class ConvolutionOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class FftOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class InfeedOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class MemRefElementCastOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class OutfeedOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class PartitionIdOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class ReplicaIdOp;
} // namespace xla_cpu
} // namespace mlir
namespace mlir {
namespace xla_cpu {
class RngBitGeneratorOp;
} // namespace xla_cpu
} // namespace mlir
#ifdef GET_OP_CLASSES
#undef GET_OP_CLASSES

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::AddDependencyOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AddDependencyOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  AddDependencyOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  AddDependencyOpGenericAdaptorBase(AddDependencyOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class AddDependencyOpGenericAdaptor : public detail::AddDependencyOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AddDependencyOpGenericAdaptorBase;
public:
  AddDependencyOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AddDependencyOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AddDependencyOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = AddDependencyOp, typename = std::enable_if_t<std::is_same_v<LateInst, AddDependencyOp>>>
  AddDependencyOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getToken() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AddDependencyOpAdaptor : public AddDependencyOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AddDependencyOpGenericAdaptor::AddDependencyOpGenericAdaptor;
  AddDependencyOpAdaptor(AddDependencyOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AddDependencyOp : public ::mlir::Op<AddDependencyOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::Type>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AddDependencyOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AddDependencyOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.add_dependency");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Value getOperand() {
    return ::llvm::cast<::mlir::Value>(*getODSOperands(0).begin());
  }

  ::mlir::Value getToken() {
    return ::llvm::cast<::mlir::Value>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getTokenMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0, ::mlir::Value operand, ::mlir::Value token);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value operand, ::mlir::Value token);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 0;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return false;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (opOperand.getOperandNumber() == 0 || opOperand.getOperandNumber() == 1)
      return {};
    return {{getOperation()->getOpResult(0),
             bufferization::BufferRelation::Unknown, /*isDefinite=*/false}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::AddDependencyOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::AllReduceOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllReduceOpGenericAdaptorBase {
public:
  struct Properties {
    using channel_handleTy = ::mlir::IntegerAttr;
    channel_handleTy channel_handle;

    auto getChannelHandle() {
      auto &propStorage = this->channel_handle;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setChannelHandle(const ::mlir::IntegerAttr &propValue) {
      this->channel_handle = propValue;
    }
    using reduction_kindTy = ::mlir::IntegerAttr;
    reduction_kindTy reduction_kind;

    auto getReductionKind() {
      auto &propStorage = this->reduction_kind;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setReductionKind(const ::mlir::IntegerAttr &propValue) {
      this->reduction_kind = propValue;
    }
    using replica_groupsTy = ::mlir::DenseIntElementsAttr;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setReplicaGroups(const ::mlir::DenseIntElementsAttr &propValue) {
      this->replica_groups = propValue;
    }
    using use_global_device_idsTy = ::mlir::IntegerAttr;
    use_global_device_idsTy use_global_device_ids;

    auto getUseGlobalDeviceIds() {
      auto &propStorage = this->use_global_device_ids;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setUseGlobalDeviceIds(const ::mlir::IntegerAttr &propValue) {
      this->use_global_device_ids = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_handle == this->channel_handle &&
        rhs.reduction_kind == this->reduction_kind &&
        rhs.replica_groups == this->replica_groups &&
        rhs.use_global_device_ids == this->use_global_device_ids &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllReduceOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  AllReduceOpGenericAdaptorBase(AllReduceOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseIntElementsAttr getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::DenseIntElementsAttr getReplicaGroups();
  ::mlir::IntegerAttr getChannelHandleAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_handle);
    return attr;
  }

  uint64_t getChannelHandle();
  ::mlir::IntegerAttr getUseGlobalDeviceIdsAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().use_global_device_ids);
    return attr;
  }

  uint32_t getUseGlobalDeviceIds();
  ::mlir::IntegerAttr getReductionKindAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().reduction_kind);
    return attr;
  }

  ::llvm::APInt getReductionKind();
};
} // namespace detail
template <typename RangeT>
class AllReduceOpGenericAdaptor : public detail::AllReduceOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllReduceOpGenericAdaptorBase;
public:
  AllReduceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllReduceOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllReduceOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = AllReduceOp, typename = std::enable_if_t<std::is_same_v<LateInst, AllReduceOp>>>
  AllReduceOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getDsts() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllReduceOpAdaptor : public AllReduceOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AllReduceOpGenericAdaptor::AllReduceOpGenericAdaptor;
  AllReduceOpAdaptor(AllReduceOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AllReduceOp : public ::mlir::Op<AllReduceOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::SameOperandsElementType, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllReduceOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AllReduceOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_handle"), ::llvm::StringRef("reduction_kind"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("use_global_device_ids")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelHandleAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelHandleAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getReductionKindAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getReductionKindAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getUseGlobalDeviceIdsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getUseGlobalDeviceIdsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.all_reduce");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperand() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getDsts() {
    return getODSOperands(1);
  }

  ::mlir::MutableOperandRange getOperandMutable();
  ::mlir::MutableOperandRange getDstsMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseIntElementsAttr getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().replica_groups);
  }

  ::mlir::DenseIntElementsAttr getReplicaGroups();
  ::mlir::IntegerAttr getChannelHandleAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_handle);
  }

  uint64_t getChannelHandle();
  ::mlir::IntegerAttr getUseGlobalDeviceIdsAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().use_global_device_ids);
  }

  uint32_t getUseGlobalDeviceIds();
  ::mlir::IntegerAttr getReductionKindAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().reduction_kind);
  }

  ::llvm::APInt getReductionKind();
  void setReplicaGroupsAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelHandleAttr(::mlir::IntegerAttr attr) {
    getProperties().channel_handle = attr;
  }

  void setChannelHandle(uint64_t attrValue);
  void setUseGlobalDeviceIdsAttr(::mlir::IntegerAttr attr) {
    getProperties().use_global_device_ids = attr;
  }

  void setUseGlobalDeviceIds(uint32_t attrValue);
  void setReductionKindAttr(::mlir::IntegerAttr attr) {
    getProperties().reduction_kind = attr;
  }

  void setReductionKind(::llvm::APInt attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange operand, ::mlir::ValueRange dsts, ::mlir::DenseIntElementsAttr replica_groups, ::mlir::IntegerAttr channel_handle, ::mlir::IntegerAttr use_global_device_ids, ::mlir::IntegerAttr reduction_kind);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange operand, ::mlir::ValueRange dsts, ::mlir::DenseIntElementsAttr replica_groups, uint64_t channel_handle, uint32_t use_global_device_ids, ::llvm::APInt reduction_kind);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 4 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state);
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state);
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state);
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::AllReduceOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::AllToAllOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class AllToAllOpGenericAdaptorBase {
public:
  struct Properties {
    using channel_id_presentTy = ::mlir::IntegerAttr;
    channel_id_presentTy channel_id_present;

    auto getChannelIdPresent() {
      auto &propStorage = this->channel_id_present;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setChannelIdPresent(const ::mlir::IntegerAttr &propValue) {
      this->channel_id_present = propValue;
    }
    using concat_dimensionTy = ::mlir::IntegerAttr;
    concat_dimensionTy concat_dimension;

    auto getConcatDimension() {
      auto &propStorage = this->concat_dimension;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setConcatDimension(const ::mlir::IntegerAttr &propValue) {
      this->concat_dimension = propValue;
    }
    using op_idTy = ::mlir::IntegerAttr;
    op_idTy op_id;

    auto getOpId() {
      auto &propStorage = this->op_id;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setOpId(const ::mlir::IntegerAttr &propValue) {
      this->op_id = propValue;
    }
    using replica_groupsTy = ::mlir::DenseIntElementsAttr;
    replica_groupsTy replica_groups;

    auto getReplicaGroups() {
      auto &propStorage = this->replica_groups;
      return ::llvm::cast<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setReplicaGroups(const ::mlir::DenseIntElementsAttr &propValue) {
      this->replica_groups = propValue;
    }
    using split_countTy = ::mlir::IntegerAttr;
    split_countTy split_count;

    auto getSplitCount() {
      auto &propStorage = this->split_count;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setSplitCount(const ::mlir::IntegerAttr &propValue) {
      this->split_count = propValue;
    }
    using split_dimensionTy = ::mlir::IntegerAttr;
    split_dimensionTy split_dimension;

    auto getSplitDimension() {
      auto &propStorage = this->split_dimension;
      return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(propStorage);
    }
    void setSplitDimension(const ::mlir::IntegerAttr &propValue) {
      this->split_dimension = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_id_present == this->channel_id_present &&
        rhs.concat_dimension == this->concat_dimension &&
        rhs.op_id == this->op_id &&
        rhs.replica_groups == this->replica_groups &&
        rhs.split_count == this->split_count &&
        rhs.split_dimension == this->split_dimension &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  AllToAllOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  AllToAllOpGenericAdaptorBase(AllToAllOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseIntElementsAttr getReplicaGroupsAttr() {
    auto attr = ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().replica_groups);
    return attr;
  }

  ::mlir::DenseIntElementsAttr getReplicaGroups();
  ::mlir::IntegerAttr getChannelIdPresentAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_id_present);
    return attr;
  }

  uint32_t getChannelIdPresent();
  ::mlir::IntegerAttr getOpIdAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().op_id);
    return attr;
  }

  uint64_t getOpId();
  ::mlir::IntegerAttr getSplitDimensionAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().split_dimension);
    return attr;
  }

  ::std::optional<uint64_t> getSplitDimension();
  ::mlir::IntegerAttr getConcatDimensionAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().concat_dimension);
    return attr;
  }

  ::std::optional<uint64_t> getConcatDimension();
  ::mlir::IntegerAttr getSplitCountAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().split_count);
    return attr;
  }

  ::std::optional<uint64_t> getSplitCount();
};
} // namespace detail
template <typename RangeT>
class AllToAllOpGenericAdaptor : public detail::AllToAllOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::AllToAllOpGenericAdaptorBase;
public:
  AllToAllOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  AllToAllOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : AllToAllOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = AllToAllOp, typename = std::enable_if_t<std::is_same_v<LateInst, AllToAllOp>>>
  AllToAllOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getDst() {
    return getODSOperands(1);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class AllToAllOpAdaptor : public AllToAllOpGenericAdaptor<::mlir::ValueRange> {
public:
  using AllToAllOpGenericAdaptor::AllToAllOpGenericAdaptor;
  AllToAllOpAdaptor(AllToAllOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class AllToAllOp : public ::mlir::Op<AllToAllOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::OpTrait::SameOperandsElementType, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = AllToAllOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = AllToAllOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_id_present"), ::llvm::StringRef("concat_dimension"), ::llvm::StringRef("op_id"), ::llvm::StringRef("replica_groups"), ::llvm::StringRef("split_count"), ::llvm::StringRef("split_dimension")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelIdPresentAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelIdPresentAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getConcatDimensionAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getConcatDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getOpIdAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getOpIdAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getReplicaGroupsAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getReplicaGroupsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getSplitCountAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getSplitCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getSplitDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getSplitDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.all_to_all");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperand() {
    return getODSOperands(0);
  }

  ::mlir::Operation::operand_range getDst() {
    return getODSOperands(1);
  }

  ::mlir::MutableOperandRange getOperandMutable();
  ::mlir::MutableOperandRange getDstMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseIntElementsAttr getReplicaGroupsAttr() {
    return ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().replica_groups);
  }

  ::mlir::DenseIntElementsAttr getReplicaGroups();
  ::mlir::IntegerAttr getChannelIdPresentAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_id_present);
  }

  uint32_t getChannelIdPresent();
  ::mlir::IntegerAttr getOpIdAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().op_id);
  }

  uint64_t getOpId();
  ::mlir::IntegerAttr getSplitDimensionAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().split_dimension);
  }

  ::std::optional<uint64_t> getSplitDimension();
  ::mlir::IntegerAttr getConcatDimensionAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().concat_dimension);
  }

  ::std::optional<uint64_t> getConcatDimension();
  ::mlir::IntegerAttr getSplitCountAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::IntegerAttr>(getProperties().split_count);
  }

  ::std::optional<uint64_t> getSplitCount();
  void setReplicaGroupsAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().replica_groups = attr;
  }

  void setChannelIdPresentAttr(::mlir::IntegerAttr attr) {
    getProperties().channel_id_present = attr;
  }

  void setChannelIdPresent(uint32_t attrValue);
  void setOpIdAttr(::mlir::IntegerAttr attr) {
    getProperties().op_id = attr;
  }

  void setOpId(uint64_t attrValue);
  void setSplitDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().split_dimension = attr;
  }

  void setSplitDimension(::std::optional<uint64_t> attrValue);
  void setConcatDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().concat_dimension = attr;
  }

  void setConcatDimension(::std::optional<uint64_t> attrValue);
  void setSplitCountAttr(::mlir::IntegerAttr attr) {
    getProperties().split_count = attr;
  }

  void setSplitCount(::std::optional<uint64_t> attrValue);
  ::mlir::Attribute removeSplitDimensionAttr() {
      auto &attr = getProperties().split_dimension;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeConcatDimensionAttr() {
      auto &attr = getProperties().concat_dimension;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeSplitCountAttr() {
      auto &attr = getProperties().split_count;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange operand, ::mlir::ValueRange dst, ::mlir::DenseIntElementsAttr replica_groups, ::mlir::IntegerAttr channel_id_present, ::mlir::IntegerAttr op_id, /*optional*/::mlir::IntegerAttr split_dimension, /*optional*/::mlir::IntegerAttr concat_dimension, /*optional*/::mlir::IntegerAttr split_count);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange operand, ::mlir::ValueRange dst, ::mlir::DenseIntElementsAttr replica_groups, uint32_t channel_id_present, uint64_t op_id, /*optional*/::mlir::IntegerAttr split_dimension, /*optional*/::mlir::IntegerAttr concat_dimension, /*optional*/::mlir::IntegerAttr split_count);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 6 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() < getNumOperands() / 2;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() >= getNumOperands() / 2;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (bufferizesToMemoryRead(opOperand, state)) return {};
    return {{getOperation()->getOpResult(opOperand.getOperandNumber() - getNumOperands() / 2),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::AllToAllOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::CollectivePermuteOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class CollectivePermuteOpGenericAdaptorBase {
public:
  struct Properties {
    using channel_handleTy = ::mlir::IntegerAttr;
    channel_handleTy channel_handle;

    auto getChannelHandle() {
      auto &propStorage = this->channel_handle;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setChannelHandle(const ::mlir::IntegerAttr &propValue) {
      this->channel_handle = propValue;
    }
    using source_target_pairsTy = ::mlir::DenseIntElementsAttr;
    source_target_pairsTy source_target_pairs;

    auto getSourceTargetPairs() {
      auto &propStorage = this->source_target_pairs;
      return ::llvm::cast<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setSourceTargetPairs(const ::mlir::DenseIntElementsAttr &propValue) {
      this->source_target_pairs = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.channel_handle == this->channel_handle &&
        rhs.source_target_pairs == this->source_target_pairs &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  CollectivePermuteOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  CollectivePermuteOpGenericAdaptorBase(CollectivePermuteOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseIntElementsAttr getSourceTargetPairsAttr() {
    auto attr = ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().source_target_pairs);
    return attr;
  }

  ::mlir::DenseIntElementsAttr getSourceTargetPairs();
  ::mlir::IntegerAttr getChannelHandleAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_handle);
    return attr;
  }

  uint64_t getChannelHandle();
};
} // namespace detail
template <typename RangeT>
class CollectivePermuteOpGenericAdaptor : public detail::CollectivePermuteOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::CollectivePermuteOpGenericAdaptorBase;
public:
  CollectivePermuteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  CollectivePermuteOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : CollectivePermuteOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = CollectivePermuteOp, typename = std::enable_if_t<std::is_same_v<LateInst, CollectivePermuteOp>>>
  CollectivePermuteOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getDst() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class CollectivePermuteOpAdaptor : public CollectivePermuteOpGenericAdaptor<::mlir::ValueRange> {
public:
  using CollectivePermuteOpGenericAdaptor::CollectivePermuteOpGenericAdaptor;
  CollectivePermuteOpAdaptor(CollectivePermuteOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class CollectivePermuteOp : public ::mlir::Op<CollectivePermuteOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = CollectivePermuteOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = CollectivePermuteOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("channel_handle"), ::llvm::StringRef("source_target_pairs")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getChannelHandleAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getChannelHandleAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getSourceTargetPairsAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getSourceTargetPairsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.collective_permute");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::ShapedType> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getDst() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDstMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseIntElementsAttr getSourceTargetPairsAttr() {
    return ::llvm::cast<::mlir::DenseIntElementsAttr>(getProperties().source_target_pairs);
  }

  ::mlir::DenseIntElementsAttr getSourceTargetPairs();
  ::mlir::IntegerAttr getChannelHandleAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().channel_handle);
  }

  uint64_t getChannelHandle();
  void setSourceTargetPairsAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().source_target_pairs = attr;
  }

  void setChannelHandleAttr(::mlir::IntegerAttr attr) {
    getProperties().channel_handle = attr;
  }

  void setChannelHandle(uint64_t attrValue);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value operand, ::mlir::Value dst, ::mlir::DenseIntElementsAttr source_target_pairs, ::mlir::IntegerAttr channel_handle);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value operand, ::mlir::Value dst, ::mlir::DenseIntElementsAttr source_target_pairs, uint64_t channel_handle);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 0;
  }
  bool bufferizesToMemoryWrite(OpOperand   &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 1;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (opOperand.getOperandNumber() == 0) return {};
    return {{getOperation()->getOpResult(0),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::CollectivePermuteOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::ConvolutionOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ConvolutionOpGenericAdaptorBase {
public:
  struct Properties {
    using batch_group_countTy = ::mlir::IntegerAttr;
    batch_group_countTy batch_group_count;

    auto getBatchGroupCount() {
      auto &propStorage = this->batch_group_count;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setBatchGroupCount(const ::mlir::IntegerAttr &propValue) {
      this->batch_group_count = propValue;
    }
    using feature_group_countTy = ::mlir::IntegerAttr;
    feature_group_countTy feature_group_count;

    auto getFeatureGroupCount() {
      auto &propStorage = this->feature_group_count;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setFeatureGroupCount(const ::mlir::IntegerAttr &propValue) {
      this->feature_group_count = propValue;
    }
    using inputBatchDimensionTy = ::mlir::IntegerAttr;
    inputBatchDimensionTy inputBatchDimension;

    auto getInputBatchDimension() {
      auto &propStorage = this->inputBatchDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setInputBatchDimension(const ::mlir::IntegerAttr &propValue) {
      this->inputBatchDimension = propValue;
    }
    using inputFeatureDimensionTy = ::mlir::IntegerAttr;
    inputFeatureDimensionTy inputFeatureDimension;

    auto getInputFeatureDimension() {
      auto &propStorage = this->inputFeatureDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setInputFeatureDimension(const ::mlir::IntegerAttr &propValue) {
      this->inputFeatureDimension = propValue;
    }
    using inputSpatialDimensionsTy = ::mlir::ArrayAttr;
    inputSpatialDimensionsTy inputSpatialDimensions;

    auto getInputSpatialDimensions() {
      auto &propStorage = this->inputSpatialDimensions;
      return ::llvm::cast<::mlir::ArrayAttr>(propStorage);
    }
    void setInputSpatialDimensions(const ::mlir::ArrayAttr &propValue) {
      this->inputSpatialDimensions = propValue;
    }
    using kernelInputFeatureDimensionTy = ::mlir::IntegerAttr;
    kernelInputFeatureDimensionTy kernelInputFeatureDimension;

    auto getKernelInputFeatureDimension() {
      auto &propStorage = this->kernelInputFeatureDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setKernelInputFeatureDimension(const ::mlir::IntegerAttr &propValue) {
      this->kernelInputFeatureDimension = propValue;
    }
    using kernelOutputFeatureDimensionTy = ::mlir::IntegerAttr;
    kernelOutputFeatureDimensionTy kernelOutputFeatureDimension;

    auto getKernelOutputFeatureDimension() {
      auto &propStorage = this->kernelOutputFeatureDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setKernelOutputFeatureDimension(const ::mlir::IntegerAttr &propValue) {
      this->kernelOutputFeatureDimension = propValue;
    }
    using kernelSpatialDimensionsTy = ::mlir::ArrayAttr;
    kernelSpatialDimensionsTy kernelSpatialDimensions;

    auto getKernelSpatialDimensions() {
      auto &propStorage = this->kernelSpatialDimensions;
      return ::llvm::cast<::mlir::ArrayAttr>(propStorage);
    }
    void setKernelSpatialDimensions(const ::mlir::ArrayAttr &propValue) {
      this->kernelSpatialDimensions = propValue;
    }
    using lhs_dilationTy = ::mlir::DenseIntElementsAttr;
    lhs_dilationTy lhs_dilation;

    auto getLhsDilation() {
      auto &propStorage = this->lhs_dilation;
      return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setLhsDilation(const ::mlir::DenseIntElementsAttr &propValue) {
      this->lhs_dilation = propValue;
    }
    using outputBatchDimensionTy = ::mlir::IntegerAttr;
    outputBatchDimensionTy outputBatchDimension;

    auto getOutputBatchDimension() {
      auto &propStorage = this->outputBatchDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setOutputBatchDimension(const ::mlir::IntegerAttr &propValue) {
      this->outputBatchDimension = propValue;
    }
    using outputFeatureDimensionTy = ::mlir::IntegerAttr;
    outputFeatureDimensionTy outputFeatureDimension;

    auto getOutputFeatureDimension() {
      auto &propStorage = this->outputFeatureDimension;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setOutputFeatureDimension(const ::mlir::IntegerAttr &propValue) {
      this->outputFeatureDimension = propValue;
    }
    using outputSpatialDimensionsTy = ::mlir::ArrayAttr;
    outputSpatialDimensionsTy outputSpatialDimensions;

    auto getOutputSpatialDimensions() {
      auto &propStorage = this->outputSpatialDimensions;
      return ::llvm::cast<::mlir::ArrayAttr>(propStorage);
    }
    void setOutputSpatialDimensions(const ::mlir::ArrayAttr &propValue) {
      this->outputSpatialDimensions = propValue;
    }
    using paddingTy = ::mlir::DenseIntElementsAttr;
    paddingTy padding;

    auto getPadding() {
      auto &propStorage = this->padding;
      return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setPadding(const ::mlir::DenseIntElementsAttr &propValue) {
      this->padding = propValue;
    }
    using precision_configTy = ::mlir::ArrayAttr;
    precision_configTy precision_config;

    auto getPrecisionConfig() {
      auto &propStorage = this->precision_config;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setPrecisionConfig(const ::mlir::ArrayAttr &propValue) {
      this->precision_config = propValue;
    }
    using rhs_dilationTy = ::mlir::DenseIntElementsAttr;
    rhs_dilationTy rhs_dilation;

    auto getRhsDilation() {
      auto &propStorage = this->rhs_dilation;
      return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setRhsDilation(const ::mlir::DenseIntElementsAttr &propValue) {
      this->rhs_dilation = propValue;
    }
    using window_reversalTy = ::mlir::DenseElementsAttr;
    window_reversalTy window_reversal;

    auto getWindowReversal() {
      auto &propStorage = this->window_reversal;
      return ::llvm::dyn_cast_or_null<::mlir::DenseElementsAttr>(propStorage);
    }
    void setWindowReversal(const ::mlir::DenseElementsAttr &propValue) {
      this->window_reversal = propValue;
    }
    using window_stridesTy = ::mlir::DenseIntElementsAttr;
    window_stridesTy window_strides;

    auto getWindowStrides() {
      auto &propStorage = this->window_strides;
      return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(propStorage);
    }
    void setWindowStrides(const ::mlir::DenseIntElementsAttr &propValue) {
      this->window_strides = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.batch_group_count == this->batch_group_count &&
        rhs.feature_group_count == this->feature_group_count &&
        rhs.inputBatchDimension == this->inputBatchDimension &&
        rhs.inputFeatureDimension == this->inputFeatureDimension &&
        rhs.inputSpatialDimensions == this->inputSpatialDimensions &&
        rhs.kernelInputFeatureDimension == this->kernelInputFeatureDimension &&
        rhs.kernelOutputFeatureDimension == this->kernelOutputFeatureDimension &&
        rhs.kernelSpatialDimensions == this->kernelSpatialDimensions &&
        rhs.lhs_dilation == this->lhs_dilation &&
        rhs.outputBatchDimension == this->outputBatchDimension &&
        rhs.outputFeatureDimension == this->outputFeatureDimension &&
        rhs.outputSpatialDimensions == this->outputSpatialDimensions &&
        rhs.padding == this->padding &&
        rhs.precision_config == this->precision_config &&
        rhs.rhs_dilation == this->rhs_dilation &&
        rhs.window_reversal == this->window_reversal &&
        rhs.window_strides == this->window_strides &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  ConvolutionOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  ConvolutionOpGenericAdaptorBase(ConvolutionOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::DenseIntElementsAttr getWindowStridesAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().window_strides);
    return attr;
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getWindowStrides();
  ::mlir::DenseIntElementsAttr getPaddingAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().padding);
    return attr;
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getPadding();
  ::mlir::DenseIntElementsAttr getLhsDilationAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().lhs_dilation);
    return attr;
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getLhsDilation();
  ::mlir::DenseIntElementsAttr getRhsDilationAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().rhs_dilation);
    return attr;
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getRhsDilation();
  ::mlir::DenseElementsAttr getWindowReversalAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::DenseElementsAttr>(getProperties().window_reversal);
    return attr;
  }

  ::std::optional< ::mlir::DenseElementsAttr > getWindowReversal();
  ::mlir::IntegerAttr getInputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().inputBatchDimension);
    return attr;
  }

  uint64_t getInputBatchDimension();
  ::mlir::IntegerAttr getInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().inputFeatureDimension);
    return attr;
  }

  uint64_t getInputFeatureDimension();
  ::mlir::ArrayAttr getInputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::ArrayAttr>(getProperties().inputSpatialDimensions);
    return attr;
  }

  ::mlir::ArrayAttr getInputSpatialDimensions();
  ::mlir::IntegerAttr getKernelInputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().kernelInputFeatureDimension);
    return attr;
  }

  uint64_t getKernelInputFeatureDimension();
  ::mlir::IntegerAttr getKernelOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().kernelOutputFeatureDimension);
    return attr;
  }

  uint64_t getKernelOutputFeatureDimension();
  ::mlir::ArrayAttr getKernelSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::ArrayAttr>(getProperties().kernelSpatialDimensions);
    return attr;
  }

  ::mlir::ArrayAttr getKernelSpatialDimensions();
  ::mlir::IntegerAttr getOutputBatchDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().outputBatchDimension);
    return attr;
  }

  uint64_t getOutputBatchDimension();
  ::mlir::IntegerAttr getOutputFeatureDimensionAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().outputFeatureDimension);
    return attr;
  }

  uint64_t getOutputFeatureDimension();
  ::mlir::ArrayAttr getOutputSpatialDimensionsAttr() {
    auto attr = ::llvm::cast<::mlir::ArrayAttr>(getProperties().outputSpatialDimensions);
    return attr;
  }

  ::mlir::ArrayAttr getOutputSpatialDimensions();
  ::mlir::IntegerAttr getFeatureGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().feature_group_count);
    return attr;
  }

  uint64_t getFeatureGroupCount();
  ::mlir::IntegerAttr getBatchGroupCountAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().batch_group_count);
    return attr;
  }

  uint64_t getBatchGroupCount();
  ::mlir::ArrayAttr getPrecisionConfigAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().precision_config);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getPrecisionConfig();
};
} // namespace detail
template <typename RangeT>
class ConvolutionOpGenericAdaptor : public detail::ConvolutionOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ConvolutionOpGenericAdaptorBase;
public:
  ConvolutionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ConvolutionOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ConvolutionOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = ConvolutionOp, typename = std::enable_if_t<std::is_same_v<LateInst, ConvolutionOp>>>
  ConvolutionOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getInput() {
    return (*getODSOperands(0).begin());
  }

  ValueT getKernel() {
    return (*getODSOperands(1).begin());
  }

  ValueT getDst() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ConvolutionOpAdaptor : public ConvolutionOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ConvolutionOpGenericAdaptor::ConvolutionOpGenericAdaptor;
  ConvolutionOpAdaptor(ConvolutionOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ConvolutionOp : public ::mlir::Op<ConvolutionOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ConvolutionOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ConvolutionOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("batch_group_count"), ::llvm::StringRef("feature_group_count"), ::llvm::StringRef("inputBatchDimension"), ::llvm::StringRef("inputFeatureDimension"), ::llvm::StringRef("inputSpatialDimensions"), ::llvm::StringRef("kernelInputFeatureDimension"), ::llvm::StringRef("kernelOutputFeatureDimension"), ::llvm::StringRef("kernelSpatialDimensions"), ::llvm::StringRef("lhs_dilation"), ::llvm::StringRef("outputBatchDimension"), ::llvm::StringRef("outputFeatureDimension"), ::llvm::StringRef("outputSpatialDimensions"), ::llvm::StringRef("padding"), ::llvm::StringRef("precision_config"), ::llvm::StringRef("rhs_dilation"), ::llvm::StringRef("window_reversal"), ::llvm::StringRef("window_strides")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getBatchGroupCountAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getBatchGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFeatureGroupCountAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFeatureGroupCountAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  ::mlir::StringAttr getInputBatchDimensionAttrName() {
    return getAttributeNameForIndex(2);
  }

  static ::mlir::StringAttr getInputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 2);
  }

  ::mlir::StringAttr getInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(3);
  }

  static ::mlir::StringAttr getInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 3);
  }

  ::mlir::StringAttr getInputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(4);
  }

  static ::mlir::StringAttr getInputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 4);
  }

  ::mlir::StringAttr getKernelInputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(5);
  }

  static ::mlir::StringAttr getKernelInputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 5);
  }

  ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(6);
  }

  static ::mlir::StringAttr getKernelOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 6);
  }

  ::mlir::StringAttr getKernelSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(7);
  }

  static ::mlir::StringAttr getKernelSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 7);
  }

  ::mlir::StringAttr getLhsDilationAttrName() {
    return getAttributeNameForIndex(8);
  }

  static ::mlir::StringAttr getLhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 8);
  }

  ::mlir::StringAttr getOutputBatchDimensionAttrName() {
    return getAttributeNameForIndex(9);
  }

  static ::mlir::StringAttr getOutputBatchDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 9);
  }

  ::mlir::StringAttr getOutputFeatureDimensionAttrName() {
    return getAttributeNameForIndex(10);
  }

  static ::mlir::StringAttr getOutputFeatureDimensionAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 10);
  }

  ::mlir::StringAttr getOutputSpatialDimensionsAttrName() {
    return getAttributeNameForIndex(11);
  }

  static ::mlir::StringAttr getOutputSpatialDimensionsAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 11);
  }

  ::mlir::StringAttr getPaddingAttrName() {
    return getAttributeNameForIndex(12);
  }

  static ::mlir::StringAttr getPaddingAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 12);
  }

  ::mlir::StringAttr getPrecisionConfigAttrName() {
    return getAttributeNameForIndex(13);
  }

  static ::mlir::StringAttr getPrecisionConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 13);
  }

  ::mlir::StringAttr getRhsDilationAttrName() {
    return getAttributeNameForIndex(14);
  }

  static ::mlir::StringAttr getRhsDilationAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 14);
  }

  ::mlir::StringAttr getWindowReversalAttrName() {
    return getAttributeNameForIndex(15);
  }

  static ::mlir::StringAttr getWindowReversalAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 15);
  }

  ::mlir::StringAttr getWindowStridesAttrName() {
    return getAttributeNameForIndex(16);
  }

  static ::mlir::StringAttr getWindowStridesAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 16);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.convolution");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::ShapedType> getInput() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getKernel() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getDst() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getInputMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getKernelMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDstMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::DenseIntElementsAttr getWindowStridesAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().window_strides);
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getWindowStrides();
  ::mlir::DenseIntElementsAttr getPaddingAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().padding);
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getPadding();
  ::mlir::DenseIntElementsAttr getLhsDilationAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().lhs_dilation);
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getLhsDilation();
  ::mlir::DenseIntElementsAttr getRhsDilationAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseIntElementsAttr>(getProperties().rhs_dilation);
  }

  ::std::optional< ::mlir::DenseIntElementsAttr > getRhsDilation();
  ::mlir::DenseElementsAttr getWindowReversalAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::DenseElementsAttr>(getProperties().window_reversal);
  }

  ::std::optional< ::mlir::DenseElementsAttr > getWindowReversal();
  ::mlir::IntegerAttr getInputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().inputBatchDimension);
  }

  uint64_t getInputBatchDimension();
  ::mlir::IntegerAttr getInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().inputFeatureDimension);
  }

  uint64_t getInputFeatureDimension();
  ::mlir::ArrayAttr getInputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::ArrayAttr>(getProperties().inputSpatialDimensions);
  }

  ::mlir::ArrayAttr getInputSpatialDimensions();
  ::mlir::IntegerAttr getKernelInputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().kernelInputFeatureDimension);
  }

  uint64_t getKernelInputFeatureDimension();
  ::mlir::IntegerAttr getKernelOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().kernelOutputFeatureDimension);
  }

  uint64_t getKernelOutputFeatureDimension();
  ::mlir::ArrayAttr getKernelSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::ArrayAttr>(getProperties().kernelSpatialDimensions);
  }

  ::mlir::ArrayAttr getKernelSpatialDimensions();
  ::mlir::IntegerAttr getOutputBatchDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().outputBatchDimension);
  }

  uint64_t getOutputBatchDimension();
  ::mlir::IntegerAttr getOutputFeatureDimensionAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().outputFeatureDimension);
  }

  uint64_t getOutputFeatureDimension();
  ::mlir::ArrayAttr getOutputSpatialDimensionsAttr() {
    return ::llvm::cast<::mlir::ArrayAttr>(getProperties().outputSpatialDimensions);
  }

  ::mlir::ArrayAttr getOutputSpatialDimensions();
  ::mlir::IntegerAttr getFeatureGroupCountAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().feature_group_count);
  }

  uint64_t getFeatureGroupCount();
  ::mlir::IntegerAttr getBatchGroupCountAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().batch_group_count);
  }

  uint64_t getBatchGroupCount();
  ::mlir::ArrayAttr getPrecisionConfigAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().precision_config);
  }

  ::std::optional< ::mlir::ArrayAttr > getPrecisionConfig();
  void setWindowStridesAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().window_strides = attr;
  }

  void setPaddingAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().padding = attr;
  }

  void setLhsDilationAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().lhs_dilation = attr;
  }

  void setRhsDilationAttr(::mlir::DenseIntElementsAttr attr) {
    getProperties().rhs_dilation = attr;
  }

  void setWindowReversalAttr(::mlir::DenseElementsAttr attr) {
    getProperties().window_reversal = attr;
  }

  void setInputBatchDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().inputBatchDimension = attr;
  }

  void setInputBatchDimension(uint64_t attrValue);
  void setInputFeatureDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().inputFeatureDimension = attr;
  }

  void setInputFeatureDimension(uint64_t attrValue);
  void setInputSpatialDimensionsAttr(::mlir::ArrayAttr attr) {
    getProperties().inputSpatialDimensions = attr;
  }

  void setKernelInputFeatureDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().kernelInputFeatureDimension = attr;
  }

  void setKernelInputFeatureDimension(uint64_t attrValue);
  void setKernelOutputFeatureDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().kernelOutputFeatureDimension = attr;
  }

  void setKernelOutputFeatureDimension(uint64_t attrValue);
  void setKernelSpatialDimensionsAttr(::mlir::ArrayAttr attr) {
    getProperties().kernelSpatialDimensions = attr;
  }

  void setOutputBatchDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().outputBatchDimension = attr;
  }

  void setOutputBatchDimension(uint64_t attrValue);
  void setOutputFeatureDimensionAttr(::mlir::IntegerAttr attr) {
    getProperties().outputFeatureDimension = attr;
  }

  void setOutputFeatureDimension(uint64_t attrValue);
  void setOutputSpatialDimensionsAttr(::mlir::ArrayAttr attr) {
    getProperties().outputSpatialDimensions = attr;
  }

  void setFeatureGroupCountAttr(::mlir::IntegerAttr attr) {
    getProperties().feature_group_count = attr;
  }

  void setFeatureGroupCount(uint64_t attrValue);
  void setBatchGroupCountAttr(::mlir::IntegerAttr attr) {
    getProperties().batch_group_count = attr;
  }

  void setBatchGroupCount(uint64_t attrValue);
  void setPrecisionConfigAttr(::mlir::ArrayAttr attr) {
    getProperties().precision_config = attr;
  }

  ::mlir::Attribute removeWindowStridesAttr() {
      auto &attr = getProperties().window_strides;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePaddingAttr() {
      auto &attr = getProperties().padding;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeLhsDilationAttr() {
      auto &attr = getProperties().lhs_dilation;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeRhsDilationAttr() {
      auto &attr = getProperties().rhs_dilation;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removeWindowReversalAttr() {
      auto &attr = getProperties().window_reversal;
      attr = {};
      return attr;
  }

  ::mlir::Attribute removePrecisionConfigAttr() {
      auto &attr = getProperties().precision_config;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value input, ::mlir::Value kernel, ::mlir::Value dst, /*optional*/::mlir::DenseIntElementsAttr window_strides, /*optional*/::mlir::DenseIntElementsAttr padding, /*optional*/::mlir::DenseIntElementsAttr lhs_dilation, /*optional*/::mlir::DenseIntElementsAttr rhs_dilation, /*optional*/::mlir::DenseElementsAttr window_reversal, ::mlir::IntegerAttr inputBatchDimension, ::mlir::IntegerAttr inputFeatureDimension, ::mlir::ArrayAttr inputSpatialDimensions, ::mlir::IntegerAttr kernelInputFeatureDimension, ::mlir::IntegerAttr kernelOutputFeatureDimension, ::mlir::ArrayAttr kernelSpatialDimensions, ::mlir::IntegerAttr outputBatchDimension, ::mlir::IntegerAttr outputFeatureDimension, ::mlir::ArrayAttr outputSpatialDimensions, ::mlir::IntegerAttr feature_group_count, ::mlir::IntegerAttr batch_group_count, /*optional*/::mlir::ArrayAttr precision_config);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value input, ::mlir::Value kernel, ::mlir::Value dst, /*optional*/::mlir::DenseIntElementsAttr window_strides, /*optional*/::mlir::DenseIntElementsAttr padding, /*optional*/::mlir::DenseIntElementsAttr lhs_dilation, /*optional*/::mlir::DenseIntElementsAttr rhs_dilation, /*optional*/::mlir::DenseElementsAttr window_reversal, uint64_t inputBatchDimension, uint64_t inputFeatureDimension, ::mlir::ArrayAttr inputSpatialDimensions, uint64_t kernelInputFeatureDimension, uint64_t kernelOutputFeatureDimension, ::mlir::ArrayAttr kernelSpatialDimensions, uint64_t outputBatchDimension, uint64_t outputFeatureDimension, ::mlir::ArrayAttr outputSpatialDimensions, uint64_t feature_group_count, uint64_t batch_group_count, /*optional*/::mlir::ArrayAttr precision_config);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 17 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() < 2;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 2;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (opOperand.getOperandNumber() < 2) return {};
    return {{getOperation()->getOpResult(0),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::ConvolutionOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::FftOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class FftOpGenericAdaptorBase {
public:
  struct Properties {
    using fft_lengthTy = ::mlir::ArrayAttr;
    fft_lengthTy fft_length;

    auto getFftLength() {
      auto &propStorage = this->fft_length;
      return ::llvm::cast<::mlir::ArrayAttr>(propStorage);
    }
    void setFftLength(const ::mlir::ArrayAttr &propValue) {
      this->fft_length = propValue;
    }
    using fft_typeTy = ::mlir::IntegerAttr;
    fft_typeTy fft_type;

    auto getFftType() {
      auto &propStorage = this->fft_type;
      return ::llvm::cast<::mlir::IntegerAttr>(propStorage);
    }
    void setFftType(const ::mlir::IntegerAttr &propValue) {
      this->fft_type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.fft_length == this->fft_length &&
        rhs.fft_type == this->fft_type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  FftOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  FftOpGenericAdaptorBase(FftOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::IntegerAttr getFftTypeAttr() {
    auto attr = ::llvm::cast<::mlir::IntegerAttr>(getProperties().fft_type);
    return attr;
  }

  uint32_t getFftType();
  ::mlir::ArrayAttr getFftLengthAttr() {
    auto attr = ::llvm::cast<::mlir::ArrayAttr>(getProperties().fft_length);
    return attr;
  }

  ::mlir::ArrayAttr getFftLength();
};
} // namespace detail
template <typename RangeT>
class FftOpGenericAdaptor : public detail::FftOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::FftOpGenericAdaptorBase;
public:
  FftOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  FftOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : FftOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = FftOp, typename = std::enable_if_t<std::is_same_v<LateInst, FftOp>>>
  FftOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getOperand() {
    return (*getODSOperands(0).begin());
  }

  ValueT getDst() {
    return (*getODSOperands(1).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class FftOpAdaptor : public FftOpGenericAdaptor<::mlir::ValueRange> {
public:
  using FftOpGenericAdaptor::FftOpGenericAdaptor;
  FftOpAdaptor(FftOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class FftOp : public ::mlir::Op<FftOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<2>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = FftOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = FftOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("fft_length"), ::llvm::StringRef("fft_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getFftLengthAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getFftLengthAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getFftTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getFftTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.fft");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::ShapedType> getOperand() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getDst() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(1).begin());
  }

  ::mlir::OpOperand &getOperandMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDstMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::IntegerAttr getFftTypeAttr() {
    return ::llvm::cast<::mlir::IntegerAttr>(getProperties().fft_type);
  }

  uint32_t getFftType();
  ::mlir::ArrayAttr getFftLengthAttr() {
    return ::llvm::cast<::mlir::ArrayAttr>(getProperties().fft_length);
  }

  ::mlir::ArrayAttr getFftLength();
  void setFftTypeAttr(::mlir::IntegerAttr attr) {
    getProperties().fft_type = attr;
  }

  void setFftType(uint32_t attrValue);
  void setFftLengthAttr(::mlir::ArrayAttr attr) {
    getProperties().fft_length = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value operand, ::mlir::Value dst, ::mlir::IntegerAttr fft_type, ::mlir::ArrayAttr fft_length);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value operand, ::mlir::Value dst, uint32_t fft_type, ::mlir::ArrayAttr fft_length);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 0;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 1;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (opOperand.getOperandNumber() == 0) return {};
    return {{getOperation()->getOpResult(0),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::FftOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::InfeedOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class InfeedOpGenericAdaptorBase {
public:
  struct Properties {
    using configTy = ::mlir::StringAttr;
    configTy config;

    auto getConfig() {
      auto &propStorage = this->config;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setConfig(const ::mlir::StringAttr &propValue) {
      this->config = propValue;
    }
    using layoutTy = ::mlir::ArrayAttr;
    layoutTy layout;

    auto getLayout() {
      auto &propStorage = this->layout;
      return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(propStorage);
    }
    void setLayout(const ::mlir::ArrayAttr &propValue) {
      this->layout = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.config == this->config &&
        rhs.layout == this->layout &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  InfeedOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  InfeedOpGenericAdaptorBase(InfeedOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::StringAttr getConfigAttr();
  ::llvm::StringRef getConfig();
  ::mlir::ArrayAttr getLayoutAttr() {
    auto attr = ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().layout);
    return attr;
  }

  ::std::optional< ::mlir::ArrayAttr > getLayout();
};
} // namespace detail
template <typename RangeT>
class InfeedOpGenericAdaptor : public detail::InfeedOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::InfeedOpGenericAdaptorBase;
public:
  InfeedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  InfeedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : InfeedOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = InfeedOp, typename = std::enable_if_t<std::is_same_v<LateInst, InfeedOp>>>
  InfeedOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getDst() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class InfeedOpAdaptor : public InfeedOpGenericAdaptor<::mlir::ValueRange> {
public:
  using InfeedOpGenericAdaptor::InfeedOpGenericAdaptor;
  InfeedOpAdaptor(InfeedOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class InfeedOp : public ::mlir::Op<InfeedOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = InfeedOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = InfeedOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("config"), ::llvm::StringRef("layout")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getLayoutAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getLayoutAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.infeed");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getDst() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getDstMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getConfigAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(getProperties().config);
  }

  ::llvm::StringRef getConfig();
  ::mlir::ArrayAttr getLayoutAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::ArrayAttr>(getProperties().layout);
  }

  ::std::optional< ::mlir::ArrayAttr > getLayout();
  void setConfigAttr(::mlir::StringAttr attr) {
    getProperties().config = attr;
  }

  void setConfig(::llvm::StringRef attrValue);
  void setLayoutAttr(::mlir::ArrayAttr attr) {
    getProperties().layout = attr;
  }

  ::mlir::Attribute removeLayoutAttr() {
      auto &attr = getProperties().layout;
      attr = {};
      return attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange dst, ::mlir::StringAttr config, /*optional*/::mlir::ArrayAttr layout);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::ValueRange dst, ::llvm::StringRef config, /*optional*/::mlir::ArrayAttr layout);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return false;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return true;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    return {{getOperation()->getOpResult(0),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::InfeedOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::MemRefElementCastOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class MemRefElementCastOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  MemRefElementCastOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  MemRefElementCastOpGenericAdaptorBase(MemRefElementCastOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class MemRefElementCastOpGenericAdaptor : public detail::MemRefElementCastOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::MemRefElementCastOpGenericAdaptorBase;
public:
  MemRefElementCastOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  MemRefElementCastOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : MemRefElementCastOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = MemRefElementCastOp, typename = std::enable_if_t<std::is_same_v<LateInst, MemRefElementCastOp>>>
  MemRefElementCastOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getSrc() {
    return (*getODSOperands(0).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class MemRefElementCastOpAdaptor : public MemRefElementCastOpGenericAdaptor<::mlir::ValueRange> {
public:
  using MemRefElementCastOpGenericAdaptor::MemRefElementCastOpGenericAdaptor;
  MemRefElementCastOpAdaptor(MemRefElementCastOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class MemRefElementCastOp : public ::mlir::Op<MemRefElementCastOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::MemRefType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::OneOperand, ::mlir::OpTrait::OpInvariants, ::mlir::OpTrait::SameOperandsAndResultShape> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = MemRefElementCastOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = MemRefElementCastOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.memref_element_cast");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::MemRefType> getSrc() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::MemRefType>>(*getODSOperands(0).begin());
  }

  ::mlir::OpOperand &getSrcMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::MemRefType> getDst() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::MemRefType>>(*getODSResults(0).begin());
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type dst, ::mlir::Value src);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::Value src);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  ::mlir::LogicalResult verify();
  static ::mlir::ParseResult parse(::mlir::OpAsmParser &parser, ::mlir::OperationState &result);
  void print(::mlir::OpAsmPrinter &_odsPrinter);
public:
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::MemRefElementCastOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::OutfeedOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class OutfeedOpGenericAdaptorBase {
public:
  struct Properties {
    using configTy = ::mlir::StringAttr;
    configTy config;

    auto getConfig() {
      auto &propStorage = this->config;
      return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(propStorage);
    }
    void setConfig(const ::mlir::StringAttr &propValue) {
      this->config = propValue;
    }
    using result_typeTy = ::mlir::ArrayAttr;
    result_typeTy result_type;

    auto getResultType() {
      auto &propStorage = this->result_type;
      return ::llvm::cast<::mlir::ArrayAttr>(propStorage);
    }
    void setResultType(const ::mlir::ArrayAttr &propValue) {
      this->result_type = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.config == this->config &&
        rhs.result_type == this->result_type &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  OutfeedOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  OutfeedOpGenericAdaptorBase(OutfeedOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize);
  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::StringAttr getConfigAttr();
  ::llvm::StringRef getConfig();
  ::mlir::ArrayAttr getResultTypeAttr() {
    auto attr = ::llvm::cast<::mlir::ArrayAttr>(getProperties().result_type);
    return attr;
  }

  ::mlir::ArrayAttr getResultType();
};
} // namespace detail
template <typename RangeT>
class OutfeedOpGenericAdaptor : public detail::OutfeedOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::OutfeedOpGenericAdaptorBase;
public:
  OutfeedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  OutfeedOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : OutfeedOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = OutfeedOp, typename = std::enable_if_t<std::is_same_v<LateInst, OutfeedOp>>>
  OutfeedOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperand() {
    return getODSOperands(0);
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class OutfeedOpAdaptor : public OutfeedOpGenericAdaptor<::mlir::ValueRange> {
public:
  using OutfeedOpGenericAdaptor::OutfeedOpGenericAdaptor;
  OutfeedOpAdaptor(OutfeedOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class OutfeedOp : public ::mlir::Op<OutfeedOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::ZeroResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::VariadicOperands, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = OutfeedOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = OutfeedOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("config"), ::llvm::StringRef("result_type")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getConfigAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getConfigAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  ::mlir::StringAttr getResultTypeAttrName() {
    return getAttributeNameForIndex(1);
  }

  static ::mlir::StringAttr getResultTypeAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 1);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.outfeed");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index);
  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::Operation::operand_range getOperand() {
    return getODSOperands(0);
  }

  ::mlir::MutableOperandRange getOperandMutable();
  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::StringAttr getConfigAttr() {
    return ::llvm::dyn_cast_or_null<::mlir::StringAttr>(getProperties().config);
  }

  ::llvm::StringRef getConfig();
  ::mlir::ArrayAttr getResultTypeAttr() {
    return ::llvm::cast<::mlir::ArrayAttr>(getProperties().result_type);
  }

  ::mlir::ArrayAttr getResultType();
  void setConfigAttr(::mlir::StringAttr attr) {
    getProperties().config = attr;
  }

  void setConfig(::llvm::StringRef attrValue);
  void setResultTypeAttr(::mlir::ArrayAttr attr) {
    getProperties().result_type = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operand, ::mlir::StringAttr config, ::mlir::ArrayAttr result_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operand, ::mlir::StringAttr config, ::mlir::ArrayAttr result_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operand, ::llvm::StringRef config, ::mlir::ArrayAttr result_type);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operand, ::llvm::StringRef config, ::mlir::ArrayAttr result_type);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void populateDefaultProperties(::mlir::OperationName opName, Properties &properties);
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 2 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return true;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return false;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    return {};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::OutfeedOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::PartitionIdOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class PartitionIdOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  PartitionIdOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  PartitionIdOpGenericAdaptorBase(PartitionIdOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class PartitionIdOpGenericAdaptor : public detail::PartitionIdOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::PartitionIdOpGenericAdaptorBase;
public:
  PartitionIdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  PartitionIdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : PartitionIdOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = PartitionIdOp, typename = std::enable_if_t<std::is_same_v<LateInst, PartitionIdOp>>>
  PartitionIdOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class PartitionIdOpAdaptor : public PartitionIdOpGenericAdaptor<::mlir::ValueRange> {
public:
  using PartitionIdOpGenericAdaptor::PartitionIdOpGenericAdaptor;
  PartitionIdOpAdaptor(PartitionIdOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class PartitionIdOp : public ::mlir::Op<PartitionIdOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::IntegerType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::InferTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = PartitionIdOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = PartitionIdOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.partition_id");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes);
public:
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::PartitionIdOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::ReplicaIdOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class ReplicaIdOpGenericAdaptorBase {
public:
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  ::mlir::RegionRange odsRegions;
public:
  ReplicaIdOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {});

  ReplicaIdOpGenericAdaptorBase(ReplicaIdOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

};
} // namespace detail
template <typename RangeT>
class ReplicaIdOpGenericAdaptor : public detail::ReplicaIdOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::ReplicaIdOpGenericAdaptorBase;
public:
  ReplicaIdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const ::mlir::EmptyProperties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  ReplicaIdOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : ReplicaIdOpGenericAdaptor(values, attrs, (properties ? *properties.as<::mlir::EmptyProperties *>() : ::mlir::EmptyProperties{}), regions) {}

  template <typename LateInst = ReplicaIdOp, typename = std::enable_if_t<std::is_same_v<LateInst, ReplicaIdOp>>>
  ReplicaIdOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class ReplicaIdOpAdaptor : public ReplicaIdOpGenericAdaptor<::mlir::ValueRange> {
public:
  using ReplicaIdOpGenericAdaptor::ReplicaIdOpGenericAdaptor;
  ReplicaIdOpAdaptor(ReplicaIdOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class ReplicaIdOp : public ::mlir::Op<ReplicaIdOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::OneResult, ::mlir::OpTrait::OneTypedResult<::mlir::IntegerType>::Impl, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::ZeroOperands, ::mlir::OpTrait::OpInvariants, ::mlir::InferTypeOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = ReplicaIdOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = ReplicaIdOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    return {};
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.replica_id");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::Type resultType0);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState);
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
  static ::mlir::LogicalResult inferReturnTypes(::mlir::MLIRContext *context, ::std::optional<::mlir::Location> location, ::mlir::ValueRange operands, ::mlir::DictionaryAttr attributes, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions, ::llvm::SmallVectorImpl<::mlir::Type>&inferredReturnTypes);
public:
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::ReplicaIdOp)

namespace mlir {
namespace xla_cpu {

//===----------------------------------------------------------------------===//
// ::mlir::xla_cpu::RngBitGeneratorOp declarations
//===----------------------------------------------------------------------===//

namespace detail {
class RngBitGeneratorOpGenericAdaptorBase {
public:
  struct Properties {
    using rng_algorithmTy = ::mlir::Attribute;
    rng_algorithmTy rng_algorithm;

    auto getRngAlgorithm() {
      auto &propStorage = this->rng_algorithm;
      return ::llvm::cast<::mlir::Attribute>(propStorage);
    }
    void setRngAlgorithm(const ::mlir::Attribute &propValue) {
      this->rng_algorithm = propValue;
    }
    bool operator==(const Properties &rhs) const {
      return 
        rhs.rng_algorithm == this->rng_algorithm &&
        true;
    }
    bool operator!=(const Properties &rhs) const {
      return !(*this == rhs);
    }
  };
protected:
  ::mlir::DictionaryAttr odsAttrs;
  ::std::optional<::mlir::OperationName> odsOpName;
  Properties properties;
  ::mlir::RegionRange odsRegions;
public:
  RngBitGeneratorOpGenericAdaptorBase(::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {});

  RngBitGeneratorOpGenericAdaptorBase(RngBitGeneratorOp op);

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index, unsigned odsOperandsSize) {
    return {index, 1};
  }

  const Properties &getProperties() {
    return properties;
  }

  ::mlir::DictionaryAttr getAttributes() {
    return odsAttrs;
  }

  ::mlir::Attribute getRngAlgorithmAttr() {
    auto attr = ::llvm::cast<::mlir::Attribute>(getProperties().rng_algorithm);
    return attr;
  }

  ::mlir::Attribute getRngAlgorithm();
};
} // namespace detail
template <typename RangeT>
class RngBitGeneratorOpGenericAdaptor : public detail::RngBitGeneratorOpGenericAdaptorBase {
  using ValueT = ::llvm::detail::ValueOfRange<RangeT>;
  using Base = detail::RngBitGeneratorOpGenericAdaptorBase;
public:
  RngBitGeneratorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs = nullptr, const Properties &properties = {}, ::mlir::RegionRange regions = {}) : Base(attrs, properties, regions), odsOperands(values) {}

  RngBitGeneratorOpGenericAdaptor(RangeT values, ::mlir::DictionaryAttr attrs, ::mlir::OpaqueProperties properties, ::mlir::RegionRange regions = {}) : RngBitGeneratorOpGenericAdaptor(values, attrs, (properties ? *properties.as<Properties *>() : Properties{}), regions) {}

  template <typename LateInst = RngBitGeneratorOp, typename = std::enable_if_t<std::is_same_v<LateInst, RngBitGeneratorOp>>>
  RngBitGeneratorOpGenericAdaptor(RangeT values, LateInst op) : Base(op), odsOperands(values) {}

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return Base::getODSOperandIndexAndLength(index, odsOperands.size());
  }

  RangeT getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(odsOperands.begin(), valueRange.first),
             std::next(odsOperands.begin(), valueRange.first + valueRange.second)};
  }

  ValueT getState() {
    return (*getODSOperands(0).begin());
  }

  ValueT getDstState() {
    return (*getODSOperands(1).begin());
  }

  ValueT getDst() {
    return (*getODSOperands(2).begin());
  }

  RangeT getOperands() {
    return odsOperands;
  }

private:
  RangeT odsOperands;
};
class RngBitGeneratorOpAdaptor : public RngBitGeneratorOpGenericAdaptor<::mlir::ValueRange> {
public:
  using RngBitGeneratorOpGenericAdaptor::RngBitGeneratorOpGenericAdaptor;
  RngBitGeneratorOpAdaptor(RngBitGeneratorOp op);

  ::mlir::LogicalResult verify(::mlir::Location loc);
};
class RngBitGeneratorOp : public ::mlir::Op<RngBitGeneratorOp, ::mlir::OpTrait::ZeroRegions, ::mlir::OpTrait::VariadicResults, ::mlir::OpTrait::ZeroSuccessors, ::mlir::OpTrait::NOperands<3>::Impl, ::mlir::OpTrait::OpInvariants, ::mlir::BytecodeOpInterface::Trait, ::mlir::bufferization::BufferizableOpInterface::Trait> {
public:
  using Op::Op;
  using Op::print;
  using Adaptor = RngBitGeneratorOpAdaptor;
  template <typename RangeT>
  using GenericAdaptor = RngBitGeneratorOpGenericAdaptor<RangeT>;
  using FoldAdaptor = GenericAdaptor<::llvm::ArrayRef<::mlir::Attribute>>;
  using Properties = FoldAdaptor::Properties;
  static ::llvm::ArrayRef<::llvm::StringRef> getAttributeNames() {
    static ::llvm::StringRef attrNames[] = {::llvm::StringRef("rng_algorithm")};
    return ::llvm::ArrayRef(attrNames);
  }

  ::mlir::StringAttr getRngAlgorithmAttrName() {
    return getAttributeNameForIndex(0);
  }

  static ::mlir::StringAttr getRngAlgorithmAttrName(::mlir::OperationName name) {
    return getAttributeNameForIndex(name, 0);
  }

  static constexpr ::llvm::StringLiteral getOperationName() {
    return ::llvm::StringLiteral("xla_cpu.rng_bit_generator");
  }

  std::pair<unsigned, unsigned> getODSOperandIndexAndLength(unsigned index) {
    return {index, 1};
  }

  ::mlir::Operation::operand_range getODSOperands(unsigned index) {
    auto valueRange = getODSOperandIndexAndLength(index);
    return {std::next(getOperation()->operand_begin(), valueRange.first),
             std::next(getOperation()->operand_begin(), valueRange.first + valueRange.second)};
  }

  ::mlir::TypedValue<::mlir::ShapedType> getState() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(0).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getDstState() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(1).begin());
  }

  ::mlir::TypedValue<::mlir::ShapedType> getDst() {
    return ::llvm::cast<::mlir::TypedValue<::mlir::ShapedType>>(*getODSOperands(2).begin());
  }

  ::mlir::OpOperand &getStateMutable() {
    auto range = getODSOperandIndexAndLength(0);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDstStateMutable() {
    auto range = getODSOperandIndexAndLength(1);
    return getOperation()->getOpOperand(range.first);
  }

  ::mlir::OpOperand &getDstMutable() {
    auto range = getODSOperandIndexAndLength(2);
    return getOperation()->getOpOperand(range.first);
  }

  std::pair<unsigned, unsigned> getODSResultIndexAndLength(unsigned index);
  ::mlir::Operation::result_range getODSResults(unsigned index) {
    auto valueRange = getODSResultIndexAndLength(index);
    return {std::next(getOperation()->result_begin(), valueRange.first),
             std::next(getOperation()->result_begin(), valueRange.first + valueRange.second)};
  }

  static ::mlir::LogicalResult setPropertiesFromAttr(Properties &prop, ::mlir::Attribute attr, ::llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::Attribute getPropertiesAsAttr(::mlir::MLIRContext *ctx, const Properties &prop);
  static llvm::hash_code computePropertiesHash(const Properties &prop);
  static std::optional<mlir::Attribute> getInherentAttr(::mlir::MLIRContext *ctx, const Properties &prop, llvm::StringRef name);
  static void setInherentAttr(Properties &prop, llvm::StringRef name, mlir::Attribute value);
  static void populateInherentAttrs(::mlir::MLIRContext *ctx, const Properties &prop, ::mlir::NamedAttrList &attrs);
  static ::mlir::LogicalResult verifyInherentAttrs(::mlir::OperationName opName, ::mlir::NamedAttrList &attrs, llvm::function_ref<::mlir::InFlightDiagnostic()> emitError);
  static ::mlir::LogicalResult readProperties(::mlir::DialectBytecodeReader &reader, ::mlir::OperationState &state);
  void writeProperties(::mlir::DialectBytecodeWriter &writer);
  ::mlir::Attribute getRngAlgorithmAttr() {
    return ::llvm::cast<::mlir::Attribute>(getProperties().rng_algorithm);
  }

  ::mlir::Attribute getRngAlgorithm();
  void setRngAlgorithmAttr(::mlir::Attribute attr) {
    getProperties().rng_algorithm = attr;
  }

  static void build(::mlir::OpBuilder &odsBuilder, ::mlir::OperationState &odsState, ::mlir::TypeRange resultType0, ::mlir::Value state, ::mlir::Value dst_state, ::mlir::Value dst, ::mlir::Attribute rng_algorithm);
  static void build(::mlir::OpBuilder &, ::mlir::OperationState &odsState, ::mlir::TypeRange resultTypes, ::mlir::ValueRange operands, ::llvm::ArrayRef<::mlir::NamedAttribute> attributes = {});
  ::mlir::LogicalResult verifyInvariantsImpl();
  ::mlir::LogicalResult verifyInvariants();
private:
  ::mlir::StringAttr getAttributeNameForIndex(unsigned index) {
    return getAttributeNameForIndex((*this)->getName(), index);
  }

  static ::mlir::StringAttr getAttributeNameForIndex(::mlir::OperationName name, unsigned index) {
    assert(index < 1 && "invalid attribute index");
    assert(name.getStringRef() == getOperationName() && "invalid operation name");
    assert(name.isRegistered() && "Operation isn't registered, missing a "
          "dependent dialect loading?");
    return name.getAttributeNames()[index];
  }

public:
  // Declarations for BufferizableOpInterface:
  bool bufferizesToMemoryRead(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() == 0;
  }
  bool bufferizesToMemoryWrite(OpOperand &opOperand,
      const bufferization::AnalysisState &state) {
    return opOperand.getOperandNumber() != 0;
  }
  bufferization::AliasingValueList getAliasingValues(
      OpOperand &opOperand, const bufferization::AnalysisState &state) {
    if (opOperand.getOperandNumber() == 0) return {};
    return {{getOperation()->getOpResult(opOperand.getOperandNumber()-1),
             bufferization::BufferRelation::Equivalent}};
  }
  LogicalResult bufferize(RewriterBase &rewriter,
      const bufferization::BufferizationOptions &options);
};
} // namespace xla_cpu
} // namespace mlir
MLIR_DECLARE_EXPLICIT_TYPE_ID(::mlir::xla_cpu::RngBitGeneratorOp)


#endif  // GET_OP_CLASSES

