import xarray as xr
import os
import glob
import pandas as pd
import gzip

from . import core, utils, diags

class Timeseries:
    ''' Initialize a CESM Timeseries case generated by CESM Postprocessing

    Args:
        root_dir (str): the root directory of the CESM Timeseries output
        grid_dict (dict): the grid dictionary for different components
        path_pattern (str): the pattern of the directories inside the root directory
    '''
    def __init__(self, root_dir, grid_dict={'atm': 'ne16', 'lnd': 'ne16', 'rof': 'ne16', 'ocn': 'g16', 'ice': 'g16'},
                 path_pattern='comp/proc/tseries/month_1/casename.mdl.h_str.vn.timespan.nc'):

        self.root_dir = root_dir
        self.path_pattern = path_pattern
        self.grid_dict = grid_dict

        utils.p_header(f'>>> case.root_dir: {self.root_dir}')
        utils.p_header(f'>>> case.path_pattern: {self.path_pattern}')
        utils.p_header(f'>>> case.grid_dict: {self.grid_dict}')

        self.paths = glob.glob(
            os.path.join(
                self.root_dir,
                self.path_pattern \
                    .replace('comp', '**') \
                    .replace('casename', '*') \
                    .replace('mdl', '*') \
                    .replace('h_str', '*') \
                    .replace('vn', '*') \
                    .replace('timespan', '*'),
            )
        )

        self.ds = {}
        self.diags = {}
        self.vars_info = {}
        for path in self.paths:
            comp = path.split('/')[-5]
            mdl = path.split('.')[-5]
            h_str = path.split('.')[-4]
            vn = path.split('.')[-3]
            if vn not in self.vars_info:
                self.vars_info[vn] = (comp, mdl, h_str)

        utils.p_success(f'>>> case.vars_info created')

    def clear_ds(self, vn=None):
        ''' Clear the existing `.ds` property
        '''
        if vn is not None:
            self.ds.pop(vn)
        else:
            self.ds = {}

    def load(self, vn, adjust_month=True, load_idx=-1, regrid=False):
        ''' Load a specific variable
        
        Args:
            vn (str or list): a variable name, or a list of variable names
            adjust_month (bool): adjust the month of the `xarray.Dataset` (the default CESM output has a month shift)
            load_idx (int or slice): -1 means to load the last file
            regrid (bool): if True, will regrid to regular lat/lon grid
        '''
        if not isinstance(vn, (list, tuple)):
            vn = [vn]

        for v in vn:
            # if v in ['KMT', 'z_t', 'z_w', 'dz', 'dzw']:
            #     vn_tmp = 'SSH'
            #     comp, mdl, h_str = self.vars_info[vn_tmp]
            #     paths = sorted(glob.glob(
            #         os.path.join(
            #             self.root_dir,
            #             self.path_pattern \
            #                 .replace('comp', comp) \
            #                 .replace('casename', '*') \
            #                 .replace('mdl', mdl) \
            #                 .replace('h_str', h_str) \
            #                 .replace('vn', vn_tmp) \
            #                 .replace('timespan', '*'),
            #         )
            #     ))
            #     with xr.load_dataset(paths[-1], decode_cf=False) as ds:
            #         self.ds[v] = ds.x[v]

            if v in self.vars_info:
                comp, mdl, h_str = self.vars_info[v]
                paths = sorted(glob.glob(
                    os.path.join(
                        self.root_dir,
                        self.path_pattern \
                            .replace('comp', comp) \
                            .replace('casename', '*') \
                            .replace('mdl', mdl) \
                            .replace('h_str', h_str) \
                            .replace('vn', v) \
                            .replace('timespan', '*'),
                    )
                ))

                # remove loaded object
                if v in self.ds:
                    if (regrid and 'regridded' not in self.ds[v].attrs) or (not regrid and 'regridded' in self.ds[v].attrs):
                        self.clear_ds(v)
                        utils.p_warning(f'>>> case.ds["{v}"] already loaded but will be reloaded due to a different regrid status')

                if v in self.ds:
                    if (load_idx is not None) and (paths[load_idx] != self.ds[v].attrs['path']):
                        self.clear_ds(v)
                        utils.p_warning(f'>>> case.ds["{v}"] already loaded but will be reloaded due to a different `load_idx`')
                
                # new load
                if v not in self.ds:
                    if load_idx is not None:
                        ds =  core.load_dataset(paths[load_idx], vn=v, adjust_month=adjust_month, comp=comp, grid=self.grid_dict[comp])
                    else:
                        ds =  core.open_mfdataset(paths, vn=v, adjust_month=adjust_month, comp=comp, grid=self.grid_dict[comp])

                    if regrid:
                        self.ds[v] = ds.x.regrid()
                        self.ds[v].attrs.update({'regridded': True})
                    else:
                        self.ds[v] = ds

                    self.ds[v].attrs['vn'] = v
                    utils.p_success(f'>>> case.ds["{v}"] created')

                elif v in self.ds:
                    utils.p_warning(f'>>> case.ds["{v}"] already loaded; to reload, run case.clear_ds("{v}") before case.load("{v}")')

            else:
                utils.p_warning(f'>>> Variable {v} not existed')

        
    def calc(self, spell, load_idx=-1, adjust_month=True, **kws):
        ''' Calculate a diagnostic spell

        Args:
            spell (str): The diagnostic spell in the format of `plot_type:diag_name:ann_method[:sm_method]`, where
                The `plot_type` supports:
                
                    * `ts`: timeseries plots
                    * `map`: 2D horizonal spatial plots
                    * `zm`: zonal mean plots
                    * `yz`: 2D lat-depth spatial plots
            
                The `plot_type:diag_name` combination supports:

                    * `ts:GMST`: the global mean surface temperature (GMST) timeseries
                    * `ts:MOC`: the meridional ocean circulation (MOC) timeseries
                    * `map:TS`: the surface temperature (TS) 2D map
                    * `map:LST`: the land surface temperature (LST) 2D map
                    * `map:SST`: the sea surface temperature (SST) 2D map
                    * `map:MLD`: the mixed layer depth (MLD) 2D map
                    * `zm:LST`: the LST 2D map
                    * `zm:SST`: the SST 2D map
                    * `yz:MOC`: the lat-depth MOC 2D map

                The `ann_method` supports:
                
                    * `ann`: calendar year annual mean
                    * `<m>`: a number in [..., -11, -12, 1, 2, ..., 12] representing a month
                    * `<m1>,<m2>,...`: a list of months sepearted by commmas
                    
                The `sm_method` supports:
                
                    * `gm`: global mean
                    * `nhm`: NH mean
                    * `shm`: SH mean

                For example,
                
                    * `ts:GMST:ann`: annual mean GMST timeseries
                    * `ts:SHH:ann:shm`: annual mean SH mean SHH timeseries
                    * `map:TS:-12,1,2`: DJF mean TS 2D map
                    * `map:MLD:3`: March MLD 2D map
                    * `zm:LST:6,7,8,9`: JJAS LST zonal mean

        '''
        spell_elements = spell.split(':')
        if len(spell_elements) == 3:
            plot_type, diag_name, ann_method = spell_elements
        elif len(spell_elements) == 4:
            plot_type, diag_name, ann_method, sm_method = spell_elements
        else:
            raise ValueError('Wrong diagnostic spell.')

        func_name = f'calc_{plot_type}_{diag_name}'
        if func_name in diags.DiagCalc.__dict__:
            self.diags[spell] = diags.DiagCalc.__dict__[func_name](
                self, load_idx=load_idx,
                adjust_month=adjust_month,
                ann_method=ann_method, **kws,
            )
        else:
            func_name = f'calc_{plot_type}'
            if 'sm_method' in locals(): kws.update({'sm_method': sm_method})

            self.diags[spell] = diags.DiagCalc.__dict__[func_name](
                self, vn=diag_name, load_idx=load_idx,
                adjust_month=adjust_month,
                ann_method=ann_method, **kws,
            )

        utils.p_success(f'>>> case.diags["{spell}"] created')

    def plot(self, spell, **kws):
        ''' Plot a diagnostic spell

        Args:
            spell (str): The diagnostic variable name in the format of `plot_type:diag_name:ann_method[:sm_method]`, see :func:`x4c.case.Timeseries.calc`
        '''
        spell_elements = spell.split(':')
        if len(spell_elements) == 3:
            plot_type, diag_name, ann_method = spell_elements
        elif len(spell_elements) == 4:
            plot_type, diag_name, ann_method, sm_method = spell_elements
        else:
            raise ValueError('Wrong diagnostic spell.')

        if 'sm_method' in locals(): kws.update({'sm_method': sm_method})
        return diags.DiagPlot.__dict__[f'plot_{plot_type}'](self, diag_name, ann_method=ann_method, **kws)

class Logs:
    ''' Initialize a CESM Log case

    Args:
        root_dir (str): the root directory of the CESM Timeseries output
    '''
    def __init__(self, dirpath, comp='ocn', load_num=None):
        self.dirpath = dirpath
        self.paths = sorted(glob.glob(os.path.join(dirpath, f'{comp}.log.*.gz')))
        if load_num is not None:
            if load_num < 0:
                self.paths = self.paths[load_num:]
            else:
                self.paths = self.paths[:load_num]

        utils.p_header(f'>>> Logs.dirpath: {self.dirpath}')
        utils.p_header(f'>>> {len(self.paths)} Logs.paths:')
        print(f'Start: {os.path.basename(self.paths[0])}')
        print(f'End: {os.path.basename(self.paths[-1])}')

    def get_vars(self, vn=[
                    'UVEL', 'UVEL2', 'VVEL', 'VVEL2', 'TEMP', 'dTEMP_POS_2D', 'dTEMP_NEG_2D', 'SALT', 'RHO', 'RHO_VINT',
                    'RESID_T', 'RESID_S', 'SU', 'SV', 'SSH', 'SSH2', 'SHF', 'SHF_QSW', 'SFWF', 'SFWF_WRST', 'TAUX', 'TAUX2', 'TAUY',
                    'TAUY2', 'FW', 'TFW_T', 'TFW_S', 'EVAP_F', 'PREC_F', 'SNOW_F', 'MELT_F', 'ROFF_F', 'IOFF_F', 'SALT_F', 'SENH_F',
                    'LWUP_F', 'LWDN_F', 'MELTH_F', 'IFRAC', 'PREC_16O_F', 'PREC_18O_F', 'PREC_HDO_F', 'EVAP_16O_F', 'EVAP_18O_F', 'EVAP_HDO_F',
                    'MELT_16O_F', 'MELT_18O_F', 'MELT_HDO_F', 'ROFF_16O_F', 'ROFF_18O_F', 'ROFF_HDO_F', 'IOFF_16O_F', 'IOFF_18O_F', 'IOFF_HDO_F',
                    'R18O', 'FvPER_R18O', 'FvICE_R18O', 'RHDO', 'FvPER_RHDO', 'FvICE_RHDO', 'ND143', 'ND144', 'IAGE', 'QSW_HBL', 'KVMIX', 'KVMIX_M',
                    'TPOWER', 'VDC_T', 'VDC_S', 'VVC', 'KAPPA_ISOP', 'KAPPA_THIC', 'HOR_DIFF', 'DIA_DEPTH', 'TLT', 'INT_DEPTH', 'UISOP', 'VISOP',
                    'WISOP', 'ADVT_ISOP', 'ADVS_ISOP', 'VNT_ISOP', 'VNS_ISOP', 'USUBM', 'VSUBM', 'WSUBM', 'HLS_SUBM', 'ADVT_SUBM', 'ADVS_SUBM',
                    'VNT_SUBM', 'VNS_SUBM', 'HDIFT', 'HDIFS', 'WVEL', 'WVEL2', 'UET', 'VNT', 'WTT', 'UES', 'VNS', 'WTS', 'ADVT', 'ADVS', 'PV',
                    'Q', 'PD', 'QSW_HTP', 'QFLUX', 'HMXL', 'XMXL', 'TMXL', 'HBLT', 'XBLT', 'TBLT', 'BSF',
                    'NINO_1_PLUS_2', 'NINO_3', 'NINO_3_POINT_4', 'NINO_4',
                ]):

        if not isinstance(vn, (list, tuple)):
            vn = [vn]

        nf = len(self.paths)
        df_list = []
        for idx_file in range(nf):
            vars = {}
            with gzip.open(self.paths[idx_file], mode='rt') as fp:
                lines = fp.readlines()

                # find 1st timestamp
                for line in lines:
                    i = lines.index(line)
                    if line.find('This run        started from') != -1 and lines[i+1].find('date(month-day-year):') != -1:
                        start_date = lines[i+1].split(':')[-1].strip()
                        break

                mm, dd, yyyy = start_date.split('-')

                # find variable values
                for line in lines:
                    for v in vn:
                        if v not in vars:
                            vars[v] = []
                        elif line.strip().startswith(f'{v}:'):
                            val = float(line.strip().split(':')[-1])
                            vars[v].append(val)

            df_tmp = pd.DataFrame(vars)
            dates = xr.cftime_range(start=f'{yyyy}-{mm}-{dd}', freq='MS', periods=len(df_tmp), calendar='noleap')
            years = []
            months = []
            for date in dates:
                years.append(date.year)
                months.append(date.month)

            df_tmp['Year'] = years
            df_tmp['Month'] = months
            df_list.append(df_tmp)
        
        df = pd.concat(df_list, join='inner').drop_duplicates(subset=['Year', 'Month'], keep='last')
        df = df[ ['Year', 'Month'] + [ col for col in df.columns if col not in ['Year', 'Month']]]
        self.df = df
        self.df_ann = self.df.groupby(self.df.Year).mean()
        self.vn = vn